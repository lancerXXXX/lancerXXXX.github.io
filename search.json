                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               [{"title":"Flutter文件管理器开发","url":"/2020/01/29/Flutter文件管理器/","content":"参考参考这个项目,并在此基础上开发Andriod Studio 创建项目我也在VScode上配置了Flutter开发环境, 但是到了一些需要原生交互的部分还是需要用到AS, 所以就选择了AS我们先解读一下main.dartimport &#39;package:flutter/material.dar  新建项目import的唯一一个包  Material: 标准的移动端和web端的视觉设计语言  flutter提供了一套丰富的Material widegetspubspec.yaml: 管理程序的assets(资源: 图片,package)yaml: 类似XML, JSON的标记性语言为app添加存储权限新建项目只有有类似这么个玩意, 我们解读一下这段代码,看明白这里的每一句话Widget: Flutter几乎所有东西都是它: 可视组件,下面两种WidgetStateless widgets 属性不可变 使用SatelessWidget构建Stateful widgets , 有下面两部分StatefullWidget 不可变Sate 可变,也就是说变化性是靠这个来的BuildContext在build(StatelessWidget.build)方法中有参数BuildContext(重写build方法来构建窗口Widget)实际上就是Element(所有Element实现了BuildContext抽象类): 阻止直接对Element进行操作每个Widget都有一个BuildContext, 每个BuildContext都属于唯一WidgetBuildContext是Widget在Widget树中的句柄也就是说 A是B的父widget, 那么A的BuildContext就是B的BuildContext的父BuildContextwidget的树就对应了BuildContext的树Flutter如何构建视图 也就是我们要看一下build(BuildContext context)这句话是什么意思Widget不是要显示在视图上的东西(虽然我们通过Widget来编写UI界面)是什么呢,显示在屏幕上的视图树是Element Tree以StatelessWidget为例,看源码先看MyApp继承的StatelessWidget  ①首先是creatElement()方法: 创建StatelessElement,参数是当前Widget 注意第三个函数就是我们重写的build方法那么就继续看StatelessElement  首先get方法: 保留Widget的引用 ②然后build方法: 我们要看到搁这了,它将当前这个StatelessElement作为参数 Widget build(BuildContext context); 解释一下为什么传的是StatelessElement  StatelessElement实现了BuildContext,所以,嗯 图示 MaterialApp然后是这里的MaterialApp,这个Widget封装了应用程序实现Metrial Design所需要的一些Wedget (参考)参数含义这里用到了title,theme,home创建MyHomePageMyHomePage 放在home参数下, 就是应用默认显示的界面是一个Stateful Widget,两部分StatefulWidgetState_MyHomePageState放入一个List&lt;FileSystemEntity&gt; files = [];","tags":["flutter"],"categories":["Flutter"]},{"title":"新东方考研英语2020绿皮书","url":"/2020/01/22/新东方考研英语绿皮书2020/","content":"2020-01-31单词记忆接联系1. bruiseBruce Lee one’s nose one’s faceno ~ on one’s bodycruise2. forecastfore(先,前) cast(抛) a sharp drop …weather forecaster3. accessac(=near,近) cess(走)give sb.  to our systemhow to gain ~ access to  itblock the  to the factory~ a computer datebaseaccessibelinaccessible4. flexibleflex(弯曲)a ~ scheduleflexibility5. alongsidealong(沿着) side(边)a girl seated  himwith his wife 6. humiliatehum(地)The boss ~d Tom7. applianceappli(apply,应用)home/domestic 用具,器具8. clauseThe Constitution include a The two coordinate s are joined by “and”9. conspicuousone very ~ featurenoticeablestriking10. protestpro(很多) test(测验)The students ed against …an official protect11. straw①put the ~ to her lip12. strifeThe controversial bill caused much ~13. detectde(去掉) tect(遮掩)2020-01-22单词记忆接联系1. geneticgene(基因) tic(有..性质的)DNA provides the ~ informationgenetically2. assess~ all the importance elementsassesableassesment3. filterThe  of the cigaretteSunlight ed through the chinks of the shuttersprefer news to be ~ed4. magnitudemagn(大)+itude(表状态)know the  of this equipment …The flood caused a  of loss/realize the ~ of this meeting5. pendulumpend(悬挂)~6. financial assistance crisis7. abounda(无) bound(边界) in employment opportunitiesThe lake s with fish8. retreatre(向后) treat(=tract,拉,拽)The enemy ed to the woodsbe in headlong lengthy s … for a much longer evaluation9. innocentin(不) noc(伤害) ent(…的)The jury declared him  It was just a  jokeSeeing this  childrenthe massacre of s10. innerthe  meaningkeep her  emotions to herself …11. scorecore(核心)the IQ A  or more~ the highest in the exam12. thrustthru(插入)The knight  his spear intoThe rocket’s  propelled it into space13. behavepeople tend to ~ differentlyHow is your new machine behaving14. tan炭Mike gets a  every summerMy skin ssunburn15. automobilea pioneer in ~ production16. unifyuni(单一)fy(使)The colnies unified to form a sovereign nationagree on a unified basic priceuniteseparatedecentralize17. dip her feet in the hot water in a book2020-01-19单词记忆接联系1. cohesivehes(her,黏附)a  social organizationa special  agent2. ariserise(出现,上升) in the futurebe thought to  from …3. complyply(填满)~ the rule of the game4. barbecuebarb(倒钩)a small  in the kitchencome to the ~ some steaks5. assumptionassume(假定,设想)a complex set of cultural new manager’s  of office …assumptivepresumptionconsumptionresumption6. interfereinter(在…之前)fer(搬运) your affairs with children’s performance7. governorgovern(统治,管理) or(人)the ~ of California8. hutlive in a ~9. cushion苦行put a ~ on the hard bench10. plastics are widely usedShap the wax figure while it is 11. budgetannual  officecut down the  to the limits ~12. bowela  cancerfrom the  of the Earth13. haulPual haul 出去be ~d out of the house14. hookhung my coat up on a  nothing but shoes15. bonusbon(好的) us(我们)I promised his a ~2020-01-18单词记忆接联系1. essenceess(存在)…he is in ~ a …2. upperstiff  lip …the  class live…3. organization4. anniversaryanni(=ann,年) vers(转)10th wedding ~5. complaincom(加强)plain(平常的)…get nothing to ~6. comparative advantage validity7. installment housethe latest  of this series8. wardwar(战争)①the country is divided into 50 make sb. a  of~ off … the invadersguardWord List 20单词记忆接联系9. compatiblepat(感情)a   roommatebe  withincompatible10. vowel~11. cementment(mend修补)build house with bricks and  the torn picture~ our friendship12. accountkeep  …on …on own’s own  …a first-hand  …by/from all s …give sb. an  of …on  of …take…into  …on any  … for for 12% for the poor harvestaccountability13. suppresssup(下) press(压) human rights/new thoughts bleeding~ information/unfavorable reportsquash restrain14. credit cardbuy it on receive intellectual enough s to get his degreemobile phone  the story of Mike’s injury15. assimilatesimil(相同) ate(使) knowledgebe d into the American cultureassimialtionabsorbdigest2020-01-17单词记忆接联系1. dignitydign(有价值的)a man of lost his 2. lobbythe  of the museumpure  talk3. destinationreach our ~4. cerealreal(真正的)make the ~ taste better5. endeavor to get better gradesan  at doing sth.6. merea  coincidencethe  mention of this name7. coalitionthe  against terrorism statements…8. identitya fake  cardtheir distinct reach an ~ view2020-01-16单词记忆接联系1. boostboast(夸耀)~ his paternal wisdom~ the school~ our own esteema ~ to our spirits2. slyspy(间谍)很as ~ as a foxon the sly3. lumpget a ~ in my throatthe words ed in my throat manufacturing and services together4. ratiothe ~ of salessex ~rate5. desperatesper(希望)give up in a  situationin  hope of …a ~ apeal6. dwellinga peaceful ~7.inducein(向里) duc(拉)every attempt I made to ~ himbe ~d byinductiondeducereduceseduce8. mammalmammapredatory ~9. zip~ up my dress10. rifle“来福枪”a shell leaving a ~trifle11. swarmwarm(…)a  ofcustomers  int the store12. installationthe  of some programsmy  as principal13. astonish~ us with your strange behaviorastonishing14. visa~ application15. conclusionin conclusionaccept several general draw a 2020-01-15单词记忆接联系1. dissipatesip(啜饮)the mist d the fortune2. orbitplanets follow the s the earth3. compositepos(放)plastic  picture4. vitamin~ pills5. turbineturb(扰乱)~ exploded6. composepos(放)~ a good bookbe ~ed oftry to ~ herselfcomposer7. odorin bad ~the ~ of pie2020-1-14单词记忆接联系1. distinctionmake a ~ between2. parcel扒手掏包mail~upoutpart and parcel of3. rotwood be ~tedperfect rot to believedecaydecompose4. rateinterest ~a ship of the first ~telephone ~at any ~sb.5. counterpartcounter(相对)be the ~ part of6. nicknamethe ~ ofsb.7. recognitionas a ~ ofrecognize8. specificationspecify(详细说明)read the ~wireless networking ~instruction10. tensiontens(拉扯)~ on the cablethe ~ of motoring~ in the familyintension11. bond绑的the ~ of love and couragedomestic ~2019-12-17单词记忆接联系1. triggertiger n. v.off2. participatein with3. intelligentlig(选择)beingsunintelligent4. puffof smoke5. respectiveapartmentsirrespective respectful6. transienttrans(穿过)happiness population workertemporarypassing7. pessimistic百事皆有错attitude view8. thronethe one9. currentair ~s new ~ belief10. outfitfit outcooking~11. crudecrud(生的) rudeoil measurebehaviorrude12. whollyallbe ~ satisfied13. retrievetriev(=find)awful situationinformationreclaim retake14. rescuefrom dangerwork15. screwcrew(工友)Turn the ~cap2019-12-16单词记忆接联系1. houndfound n. v.2. flushtoilet with withdouche redden3. voluntary4. volenteera. n.5. shrinkwrinkleshrink away/back from6. hatredhate7. intensivetraining8. kettle开透9. nominalnomin(名字)member sumtitular actualIf you put out your hands, you are a labour; if you put your hands and mind, you are a craftsperson; if you put out your hands, mind and soul, you are an artist.—-美国纪录片 America’s Heart and SoulWordList 19单词记忆接联系10. consultanthealth program2019-12-15consecutive  secut(跟随)leisure  (wear)confirm  firm(坚固的)superbenhance  hanc(提高)invers  vers(转)contend  tend(张开)  maintain contestblast  最后一声响stretch  fetchobedient  obey2019-12-14conform con form (to/with)basiscomponent element constituentretain tain(持有)henceforth forthpeer beer (pressure, into the mist)bargin probe prob(证明)relish enjoy appreciate (mango relish) detestharassment harasscylinder (car)versatile vers(转)2019-12-13specifydespise despite admire esteem respectdemocratic (atmosphere)slap lap(拍打) punch kick club whipsmash ash(灰烬)maritalverse vers(转)insulate insul(绝缘)gravity glow flow glowingstationary stationequationprompt (respons,payment,thoughts,sb.to)retire (to the boder,=go to bed)maleoccupation (v. n.)preoccupationoath bath mathrepression press constraint suppression2019-12-11tropicalfeastbellylocalvigorous2019-12-10invariabletoughresortdominantobviousharmonydepressvolumetensewidespreadbudcolonycloakcorridor2019-12-06corrodehandyhumidityproceeddisposalrefineepisoderelayliverclarifyshabbyprohibitmortalextinctplumberdifferentiatenormalizationcentigradepreferablelaneejectcalciumshavecaloriehypothesisballetentitygermdnouncebachelorimpacttolerance","tags":["英语","考研"],"categories":["英语","考研"]},{"title":"windows_vim_配置","url":"/2020/01/21/windows_vim_配置/","content":"Windows上配置vim8.1介绍下情况, 之前是在wsl上使用rwindowsTerminal+angeer+vim_8为什么使用wsl, 有些软件Windows离不开, cmd是屎, ranger太香, linux太香为什么要windows装gvim, , 因为wsl, windowsteminal有bug其次是性能的问题  我的配置(常用快捷键/命令)&lt;leader&gt; : 空格(Space)文件操作&lt;leader&gt;w : 保存&lt;leader&gt;WQ : 保存退出bufferml : 循环下一个buffermh : 循环洗一个bufferNerdTree&lt;C-y&gt; : 打开关闭NerdTreei : 水平分割,新buffers : 垂直分割,新buffero : 新buffergi : 同上,但是光标仍在NerdTreegs/go : 类似窗口&lt;leader&gt;+[h/j/k/l]+w : 切换上下左右窗口 nw : 循环切换下一个窗口bullets.vim插件&lt;C-t&gt; : 列表降一级&lt;C-d&gt; : 列表升一级先选中 :Renumber. :tab补全记不全整个命令: 把你选中的乱的列表重新标号下载安装官网下载安装一路默认配置文件windows上配置文件是_vimrc, 和linux上的.vimrc不同  关于wsl的配置和linux上vim的配置可以看我以前的文章, 在分类里找  _vimrc 文件放到 c:\\用户\\用户名 下_vimrc 是我在wsl上直接拿过来的,最前面加上了四行 set 关于编码的配置, 不然的话中文显示会乱码第六行 expand(&quot;~/.vimrc.bundles&quot;) , 这是加载另一个文件 .vimrc.bundles , 这里的东西直接写在 _vimrc 里也可以, 但是这样太臃肿所以 .vimrc.bundles 用来写所有安装的插件, _vimrc 用来写对这些插件的配置以及vim的配置~ 是linux的写法, 但是这样在windows里可以用, 我就懒得改了.vimrc.bundles 里相对于在wsl中我删了一些插件, 所以 _vimrc 中有些多余的配置, 我懒得删, 但是可以用, 你直接复制就能用, 介意的话就自己找一找删掉  .vimrc.bundles 文件放到 c:\\用户\\用户名 下Vundle是用来集中管理安装的插件的插件现在是好像是有比这样更好的插件管理工具但是我懒得换了, 应为Vundle  可以用, 如果介意的话可以去查一查文件中 set rtp+=~/.vim/bundle/Vundle.vim 这个是配置要下载的插件的安装位置~ 指的是 c:\\用户\\用户名 , 不是windows的写法, 但是可以用配置要安装的插件, 插件的功能我已经加了注释直接复制安装Vundle  安装到这个目录下 C:\\用户\\用户名\\.vim\\bundle 目录自己建, github 搜 Vundle, 上面有安装教程, 克隆到这个目录下 C:\\用户\\用户名\\.vim\\bundle 安装插件随便新建个文件, 右键用gvim打开  vim基础就不说了  :VundleInstall 安装插件关于这个配色, 是一个配色的插件, 叫 edge什么的配置文件了有, 你执行完安装插件也是这样这几个插件好像都不用梯子, github上下载, 比较慢, 多等会儿markdown预览插件安装这个好像是因为Vundle插件的问题, 需要手动安装一下vim normal模式, 命令 call mkdp#util#install() 等待安装完毕具体可以看这里Ultisnips配置这是个代码块引擎插件ultisnips是代码块引擎插件vim-snippets是代码块, 是一些常用的代码块你可以自己写一些代码块放在插件ultisnips\\UltiSnips目录下, 自己新建怎么写片段自己查YouCompleteMe安装命令行cd到 C:\\用户\\用户名\\.vim\\bundle\\YouCompleteMe 目录下bundel 下就是放vim插件的地方   命令 git submodule update --init --recursive    这个是下载这里的东西      !! 需要梯子 !!   算了, 懒得写了   看这里Python支持现在YCM和Ultisnips都用不了, 会报错添加Python支持就好了先添加vim环境变量 C:\\Program Files (x86)\\Vim\\vim81参考这篇文章自已下载自已下载源码重新编译gvim安装python3.6但是，一来我懒，二来我不想用python旧版本于是下载了https://www.python.org/ftp/python/3.6.8/python-3.6.8-embed-win32.zip，直接解压缩到gvim的目录，搞定！原文链接gvim 目录是指 C:\\Program Files (x86)\\Vim\\vim81 压缩文件里那一堆东西直接扔到这个目录下"},{"title":"4_运行时存储空间的组织和管理","url":"/2020/01/13/4_运行时存储空间的组织和管理/","content":"1. 运行时存储空间的组织和管理通常的命令式编程语言表现: 多个函数的实现和相互调用入口函数-mian()代码执行过程-依据过程调用关系形成一个(调用结构图)辅助(存储空间)-每个过程的执行过程的代码- 需要一定存储空间过程中的局部变量-需要存储空间暂存词法,语法,语义分析后生成目标代码前程序的静态正文&amp;实现这个程序的运行时的活动  联系起来弄清楚 将来在 代码运行时刻代码中的各种(变量,常量,等用户定义的量)如何存放,如何访问程序的执行过程中程序中数据的存取 通过 与之对应的存储单元来进行的存储单元表示--标识符对应的内存地址由编译程序或由其生成的目标程序运行时进行分配1.1. 过程的活动 (概念一)过程的一次执行--过程的一次活动1.2. 活动记录 (概念二)过程活动时存放所需信息的存储空间1.3. 活动的生存期过程P一次活动的生存期从执行该过程第一步操作--最后一步操作之间的操作时间过程可以时递归的一个过程可对应多个活动1.4. 影响存储分配策略的语言特征过程 能否 递归局部变量的值是否保留: 当控制从过程的活动返回时过程 能否 访问非局部变量过程 调用的参数传递方式过程能否作为参数被传递过程能否作为结果值传递存储块能否在程序控制下动态地分配存储块是否必须显式地释放1.5. (过程内部)局部存储分配策略1.5.1. 过程过程定义是一个声明最简形式: 一个名字(过程名)和一个语句(过程体)联系起来返回值的过程: 函数完整的程序也可以看作一个过程过程调用被调用: 过程名出现在调用语句中, 称在该点.this: 执行被调用过程 的 过程体形式参数出现在过程调用中的某些名字实在参数过程调用中的.this传递给被调用过程,取代过程体中的形参活动的生存期1.5.2. 名字的作用域和绑定名字的作用域一个名字在程序中出现时,改名字的哪个声明应用到这个出现一个声明起作用的程序部分称为该声明的作用域即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象名字（变量）的作用域和绑定环境: 函数(将名字映射到存储单元)状态: 函数(存储单元映射到它所保存的值)环境把名字映射到左值（存储单元），而状态把左值映射到右值（值）。赋值改变状态，但不改变环境。 如果环境将名字x映射到存储单元s，就说x被绑定到s。1.5.3. 静态概念和动态概念的对应静态概念动态对应过程的定义过程的活动名字的声明名字的绑定声明的作用域绑定的生存期1.5.4. 活动记录(帧)被编译程序每次运行时，编译器从操作系统获得一块存储区（内存）。其内容包括：编译后的目标代码 (可执行程序 .exe)数据对象 (各种静态变量和动态变量)用于管理过程活动的控制栈 (活动记录 )一般的活动记录的布局(各个域)寄存器往往可以取代它们中的一个或多个域域用途例临时数据本过程计算中可能用到的临时变量寄存器放不下表达式结果,可以放这局部数据本过程内部定义的局部变量&nbsp;机器状态用于保存本过程前的机器状态(典型)返回地址(程序计数器的值),要用的并且要恢复的寄存器的内容访问链用于引用存于其他活动记录的非局部数据&nbsp;控制链指向 调用过程的指针&nbsp;返回值本过程返回给调用过程的值也常常用寄存器返回-效率实在参数调用过程传递给本过程的参数也常常用寄存器传参-效率每个域的长度都可以在过程调用时确定几乎所有域的长度可以在编译时确定例/外: 过程开始执行后才能确定大小的局部数组执行到过程调用时才能确定局部数据域的大小1.5.5. 局部数据的布局最小单位:字节是可编址内存的.this。一个过程所声明的局部变量，按这些变量声明时出现的次序，在活动记录的局部数据区中依次分配空间。 局部数据的地址可以用相对于某个位置（本过程对应的活动记录的起始位置）的偏移来表示。数据对象的存储安排深受目标机器寻址方式的影响，存在对齐问题。例如，要求整数（int，long）的相对地址可以被4整除。由于对齐而引起的无用空间称为衬垫空白区。1.5.6. 程序块本身含有局部变量声明的语句特点嵌套结构--程序块结构程序块中声明的作用域是按最接近的嵌套规则给出的编译器存储分配时,也为内嵌程序块声明的变量留出所需的空间1.6. 三种存储分配方式1.6.1. 运行时内存的划分内存划分存放对应确定时间代码目标代码(.exe)&nbsp;编译时,运行时不会改变静态区静态变量&amp;外部变量(全局变量)静态分配策略编译时,数据尽可能放这--可编译到目标代码中,效率堆杂乱无章(动态分配的内存)堆式分配策略向高地址增长空闲内存&nbsp;&nbsp;&nbsp;栈确定的(活动记录)栈式分配策略向低地增长1.6.2. 静态分配策略名字在程序被编译时绑定到存储单元，不需要运行时的任何支持。绑定的生存期是程序的整个运行时间。控制再次进入该过程时，局部变量的值和控制上一次离开时的一样。每个活动记录的大小是固定的。过程调用时保存信息的地址在编译时也是已知的。1.6.2.1. 静态分配给语言带来限制递归过程不被允许数据对象的长度和它在内存中位置，必须是在编译时可以知道的数据结构不能动态建立1.6.2.2. 静态分配的应用Fortran语言被设计成允许静态存储分配C语言程序的外部变量和程序中出现的常量都可以静态分配。声明在函数外面外部变量声明在函数里面静态局部变量常量1.6.3. 栈式存储分配栈式分配-主要用于-管理过程的活动记录局部变量 的 生存期 是过程活动的时间控制进入该过程时,局部变量绑定到存储单元过程活动结束后, 局部变量的空间释放活动记录弹栈1.6.3.1. 活动树结点--过程活动根节点--主活动结点a是b的父节点--控制流从活动a进入b结点a在b的左边--活动a的生存期先于b控制处于某节点代表的活动--控制处于这个结点1.6.3.2. 运行栈控制栈: 活动开始时压入栈,结束时从栈中弹出把控制栈中的信息拓广到包括过程活动所需的所有局部信息(即活动记录)--控制栈中的信息包括活动的活动记录当过程被调用新活动记录压入栈局部变量 绑定 其中存储单元当调用的活动终止时活动记录退栈局部变量 不绑定 其中的存储单元 (恢复原来的绑定)过程的每次调用都引起一个新的活动记录进栈所以, 过程的每次活动都会把局部变量绑定到新的存储单元1.6.3.3. 调用序列其实就是程序过程调用和过程返回都要执行一些代码来管理活动记录栈,保存或恢复机器状态等过程调用序列过程调用时执行的分配活动记录把信息填入它的域中使被调用过程可以开始执行的代码过程返回序列被调用过程返回时执行的恢复机器状态,释放被调用过程活动记录,是调用过程能够继续执行的代码1.6.3.4. (特例)过程的参数个数可变参数函数返回值用寄存器传递计算参数之后 实参逆序进栈 通过先拿到的参数可以推算后面参数的位置 (printf(&quot;%d,%d\\n&quot;);)1.6.3.5. (特例)栈上可变长数据&nbsp;活动记录的长度在编译时不能确定的情况编译时, 为数组分配数组指针的单元(活动记录中)运行时, 指针指向在栈顶分配的数组存储空间1.6.3.6. 悬空引用1.6.4. 堆式分配过程活动停止后, 局部名字的值还需要维持活动(被调用者)活的更长, 活动树不能正确描绘控制流特点内存分配与释放按任意次序进行堆中包含 交错的 正在使用的 &amp; 已经释放的区域1.6.5. 三种存储分配策略的比较&nbsp;静态分配栈式分配堆式分配存储空间静态数据区栈区堆区使用范围外部变量,静态局部变量,常量局部变量,形参动态变量分配时间程序开始前进入过程前用户决定释放时间程序结束后过程结束用户决定地址计算时间编译时运行时运行时存取速度快慢慢1.7. 非局部名字的访问介绍过程内部如何访问过程外部声明的名字静态作用域无过程嵌套又过程嵌套动态作用域1.7.1. 无过程嵌套的静态作用域过程体中的非局部引用可以直接使用静态确定的地址（非局部数据此时就是全局数据）局部变量在栈顶的活动记录中，可以通过base_sp指针来访问无须深入栈中取数据，无须访问链过程可以作为参数来传递，也可以作为结果来返回1.7.2. 有过程嵌套的静态作用域1.7.2.1. 访问链: 指向本活动最近的外围活动的记录1.7.2.2. 建立访问链过程p:n_{p}过程x:n_{x}  n_{p} &lt; n_{x}n_{p}\\geq n_{x}n_{p}-n_{x}+11.7.3. 动态作用域被调用过程的非局部名字a和它在调用过程中引用的是同样的存储单元基于运行时的调用关系而不是基于静态作用域来确定新的绑定仅为被调用过程的局部名字建立，这些名字在被调用过程的活动记录中占用存储单元这一点与静态作用域没有区别1.7.3.1. 实现动态作用域的方法深访问用控制链搜索运行栈，寻找包含该非局部名字的第一个活动记录浅访问(常用)为每个名字在静态分配的存储空间中保存它的当前值当过程p的新活动出现时，p的局部名字n使用在静态数据区分配给n的存储单元。n的先前值可以保存在p的活动记录中，当p的活动结束时再恢复1.8. 参数传递1.8.1. 引用调用1.8.2. 换名调用(现在不用了 过时了)2. 中间代码生成区分前端和后端优点移植,与机器无关表示(中间语言)后缀表示后缀表达式E: 变量/常数 --&gt;它本身E_1 op E_2--&gt;E_1'E_{2}'op(E)--&gt;E&#39;:后缀表示不需要括号图形表示语法树/有向无环图(Directed Acyclic graph,DAG)例 a=(-b+c*d)+c*d后缀表达式: a\\ b\\ uminus\\ c\\ d\\ *\\ +\\ c\\ d\\ *\\ +\\ assign三地址代码三地址代码静态单赋值形式,就是重复赋值的话就加个角标x产生分支赋值- 就x_{1},x_{2},最后合并x_3=\\phi (x_1,x_2)2.1. 声明语句符号表:为局部名字建立条目(类型,存储单元相对地址)分配存储单元offset:相对地址(偏移量计数)2.1.1. 符号表mkTable(previous) 返回符号表指针enter(table,name,type,offset) 为变量nameaddWidth(table,width) 局部变量条目 的 累加宽度- 符号表的首部enterProc(table,name,newtable) 过程名name3. 代码生成绝对机器语言程序内存固定地方可重定位目标模块代码包含可重定位信息汇编语言程序指定的选择逐条翻译,效率低下寄存器分配选驻留寄存器的一组变量寄存器指派选变量要驻留的寄存器计算次序的选择指令代价附加代价  对应  指令以字计算的长度源地址模式附加代价目的地址附加代价1+源地址模式附加代价+目的地址附加代价模式形式地址附加代价寄存器RR0间接寄存器*Rcontents(R)0绝对地址MM1变址c(R)c+contents(R)1间接变质*c(R)contents(c+contens(R))1直接量#cc1","tags":["编译原理"],"categories":["编译原理"]},{"title":"3_语义分析","url":"/2020/01/13/3_语义分析/","content":"1. 语义分析主流技术语法制导翻译技术功能静态语义审查每个语法结构的.this(eg. 类型,运算,维数,越界)之后,翻译(真正的.this)eg. 变量的存储分配/表达式的求值/语句的翻译(中间代码的生成)1.1. 语义规则和产生式联系的两种方式语义规则的两种描述方法1.1.1. 语法制导的定义带属性和规则的上下无关文法1.1.1.1. 基础文法属性(翻译)文法定义语义规则函数无副作用 的 语法制导定义副作用过程调用/程序段--&gt;可以看成 产生式左部非终结符 的虚拟综合属性eg. 打印, 输出中间代码....语义信息是上下文有关的衔接: 上下文无关文法 &amp; 程序语义基础文法文法符号--&gt;一组属性产生式--&gt;一组语义规则(属性的计算规则)属性:  串 数值  类型  表引用 ... 语法制导定义中   文法--&gt;基础文法1.1.1.1.1. 综合属性属性b在左边, 产生式右部或者A的其他属性决定子节点来计算终结符只有综合属性1.1.1.1.1.1. S属性定义自下而上计算语法制导定义 --仅用综合属性 \\rightarrowS-属性文法使用自下而上分析器边分析边计算--不用单独(语义分析 编译分析)分析完毕, 属性也计算完毕:效率,限制节点访问次序注释分析树结点的属性值都标注出来语法树分析树的浓缩表示内部节点: 算符 和 关键字语法制导翻译 基于 分析树 或者 语法树语法mknode(op,left,right): 建立运算符结点mkleaf(id, entry) : 建立标识符结点mkleaf(num, val): 建立数结点1.1.1.1.2. 继承属性左递归的消除会引起继承属性信息流动方式改变属性b在右边,由A的属性或右部文法符号的属性决定节点的兄弟节点, 父节点, 自己的属性值来计算方便表示语言结构 上下文依赖关系1.1.1.1.2.1. L属性定义自上而下计算,如果每个产生式 A\\rightarrow X_1,X_2 \\cdot \\cdot \\cdot X_n 的每条语义规则计算的属性是A的综合属性；  (所引用的所有属性都计算完才能计算)或者是X_j 的继承属性，1 \\leqslant j \\leqslant n, 但它仅依赖：该产生式中X_j左边符号X_1, X_2, …, X_{j-1}的属性；A的继承属性。S属性定义属于L属性定义和S属性区别1.S: 只将产生式作为一个整体看待2.S: 语义规则附着在整个产生式上3.L: 和 属性所属 的 符号 在产生式中的位置有关翻译方案\\rightarrow为了对L属性定义进行翻译给出 使用语义规则 的计算的次序文法符号相关的 语义动作, 用\\{\\}括起来 , 插入到产生式 右部的合适位置上动作和分析 交错的方法, 表示: 动作的时机建立翻译方案只有综合属性: 有综合属性和继承属性必须: 产生式右边的符号的继承属性必须在先于这个符号的动作中计算出来不能: 一个动作不能引用这个动作右边的符号的综合属性只有: 产生式左边非终结符的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的末尾。问题自下而上 分析中: 语义动作的执行是在使用产生式对句柄进行归约的时候但是: L属性定义的继承属性的计算需要嵌在产生式右部不同的地方解决:通过改写文法，使得所有嵌入在产生式中间的动作变换成只在产生式的最右端出现特殊情况一：删除翻译方案中嵌入的动作在文法中加入产生\\epsilon的标记非终结符，让每个嵌入动作由不同标记非终结符M代表，并把该动作放在产生式M\\rightarrow\\epsilon的右端特殊情况二：分析栈上的继承属性所依赖的属性在分析栈上的位置能静态确定属性位置能预测复写规则 b的继承属性copy了a的综合属性,那就只保存a的综合属性,b用的时候就在栈中取a的综合属性一般情况 模拟继承属性的计算不能与之属性值在栈中所放位置通过标记非终结符M复写属性的值引进标记非终结符号对基础文法的影响基础文法是LL(1)文法没有影响，修改后的文法仍将保持LL(1)文法。因为每个标记非终结符号是唯一的，而且只有唯一一个的产生式基础文法是LR(1)文法可能使修改后的文法变成非LR(1)文法1.1.1.1.2.2. 递归下降翻译器1.1.1.1.2.3. 用综合属性代替继承属性1.1.1.2. 语义规则产生式  配备  一组属性 ---计算规则1.1.1.2.1. 语义规则函数副作用:  打印 输出中间代码  修改全程量... 1.1.1.2.2. 属性文法语义规则函数无副作用  的  语法制导定义1.1.2. 语法制导的翻译方案产生式右部插入相应的动作2. 运行时存储空间的组织和管理通常的命令式编程语言表现: 多个函数的实现和相互调用入口函数-mian()代码执行过程-依据过程调用关系形成一个(调用结构图)辅助(存储空间)-每个过程的执行过程的代码- 需要一定存储空间过程中的局部变量-需要存储空间暂存词法,语法,语义分析后生成目标代码前程序的静态正文&amp;实现这个程序的运行时的活动  联系起来弄清楚 将来在 代码运行时刻代码中的各种(变量,常量,等用户定义的量)如何存放,如何访问程序的执行过程中程序中数据的存取 通过 与之对应的存储单元来进行的存储单元表示--标识符对应的内存地址由编译程序或由其生成的目标程序运行时进行分配","tags":["编译原理"],"categories":["编译原理"]},{"title":"2_语法分析","url":"/2020/01/13/2_语法分析/","content":"1. 语法分析目标:语法记号(token)流 \\rightarrow 语法短语 (分析树)实质:无结构数据 \\rightarrow 有结构数据依据:上下无关文法1.1. 上下无关文法正规式定义简单的语言给定结构 固定次数/无指定次数 重复描述配对/嵌套四元组V_T 终 非空有限 记号名-同义词V_N 非 非空有限 和终无交集S 开始符号P 产生式集合1.2. 最左推导1.3. 最右推导1.4. 判断满足语法规则(语法分析目标)存在推导 \\rightarrow 推导出给定句子1.5. 二义性常见且需要避免符合文法规则-句子 : 存在两种可能的分析树无二义性左右推导 \\rightarrow 语法树相同唯一 左右 推导1.5.1. 产生原因符号优先级没有体现1.6. 优点精确, 易理解-语法说明自动产生 高效分析器给 语言 定义出 层级结构便于 语言的修改 (以文法为基础)1.7. 缺点只能 描述 编程语言的 大部分语法1.8. NFA \\rightarrow 上下文无关文法确定 终结符集合状态 \\rightarrow A_i转换(a) &emsp; A_i\\rightarrow aA_j &ensp; / 接受状态 &ensp; A_i\\rightarrow \\epsilon1.9. 分离词法分析器理由正规式定义词法规则简单 不比上下文无关文法词法记号-正规式 描述 简洁/易理解正规式构造 词法分析器 效率高简化设计编译器 效率编译器 移植性编译器 前端 模块划分语法分析器规则 不必 考虑 注解和空白1.10. 自上而下分析(语法分析途径之一)基本思想寻找 最左推导 分析树try 根据 当前输入单词 确定 使用哪个 产生式  (试探和回溯)试探与回溯是一种穷尽一切可能的办法, 效率低, 代价高, 只有理论意义, 在实践中用处不大基本过程S出发构造Token 最左推导构造Token 分析树 (最左推导顺序)文法 G=(V_T, V_N, S, P)0型 : 短语1型 : 上下文有关2型 : 上下文无关3型 : 正规式 正规文法LL(1)文法L(Left):自左向右扫描 L(Left): 使用最左推导1:向前看一个符号,预测避免回溯不带回溯的自上而下文法判断是不是LL(1)文法当且仅当对于G的每个非终结符A的任何两个产生式A → α | β，有：改为LL(1)文法消除左递归,提取左因子 (不一定成功)消除左递归 避免回溯(消除二义性)速递下降的预测分析消除二义性大多数编程语言使用有二义性的语言, 因为消除后的会失去了简洁性. 文法有二义性不可怕, 只要有消除二义性的规则就可以了消除方法 : 体现运算符的优先次序 &amp; 结合规则非二义文法的产生式如下\\begin{aligned}&S\\rightarrow S\\ and S\\ |\\ S\\ or\\ S\\ |\\ not \\ S|\\ p\\ |\\ q\\ |\\ (S)\\ \\\\&非二义文法的产生式如下:\\\\&E \\rightarrow E \\ or \\ T \\ | \\ T\\\\&T \\rightarrow T \\ and \\ F \\ | \\ F \\\\&F \\rightarrow not \\ F \\ | \\ (E)\\ | \\ p \\ | \\ q\\end{aligned}优先级高的后写消除左递归也就是变成右递归文法左递归: A\\Rightarrow^+A\\alpha直接左递归: A\\rightarrow A\\alpha|\\beta\\begin{aligned}&A\\rightarrow\\beta A' \\\\&A'\\rightarrow\\alpha A'|\\epsilon\\end{aligned}间接左递归S\\rightarrow Ac|c\\ \\ \\ A\\rightarrow Bb|b\\ \\ \\ B\\rightarrow Sa|aB定义代入AA定义带入S消除左递归\\begin{aligned}&S\\rightarrow abcS'|bcS'|cS' \\\\&S'\\rightarrow abcS'|\\epsilon\\end{aligned}其他的删掉提左因子推迟决定换成\\begin{aligned}&A\\rightarrow \\alpha\\beta_1|\\alpha\\beta_2|\\gamma_1|\\gamma _2\\\\&换成\\\\&A\\rightarrow\\alpha A'|\\gamma _1|\\gamma_2\\\\&A\\rightarrow\\beta_1|\\beta_2\\end{aligned}避免回溯First集合       1. X是终结符, 则First(X)=X       2. X是非终结符, 有X\\rightarrowa... , 则First(X)={a}       3. X是非终结符, 有X\\rightarrow Y_1Y_2... Y_K, Y_1... Y_{i-1}\\rightarrow \\varepsilon, 把First(Y_i)-\\varepsilon添加到First(X)中, 如果到Y_N都能\\rightarrow \\varepsilon, 把\\varepsilon也添加到First(X)Follow集合所有句型中紧跟在 A 后面的终结符集合将 \\$ 放入Follow(S)中若A\\rightarrow \\alpha B\\beta, 将First(\\beta)-{\\varepsilon}加入Follow(B)中, (\\alpha可以为空)若A\\rightarrow \\alpha B或者A\\rightarrow\\alpha B\\beta, 且\\varepsilon\\in First(\\beta), 则将Follow(A)加入Follow(B)中, (\\alpha可以为空)任意两个产生式 A\\rightarrow\\alpha|\\beta应要满足1.FIRST(\\alpha)\\cap FIRST(\\beta)=\\varnothing2.\\beta\\Rightarrow^*\\epsilon\\rightarrow FIRST(\\alpha)\\cap FOLLOW(A)=\\varnothing  否则遇到第二步不知用哪条\\begin{aligned}&否则\\\\&S\\rightarrow AB\\\\&A\\rightarrow ab|\\epsilon\\\\&B\\rightarrow aC \\\\&遇到a... ., 第二步不知用哪条\\end{aligned}预测分析符号栈 \\$S, 输入....\\$根据当前的输入符号为非终结符确定采用哪一个选择递归下降的预测分析非递归的预测分析表驱动的预测分析器有一个 输入缓冲区 一个栈 一张 分析表 一个 输出流1.X=a=\\$, 成功停机2.X=a\\neq\\$, pop() , 输入指针推进, 指向下一个符号3.X是终结符但不是 a , 出错, 调用错误恢复程序4.X是非终结符, 访问分析表 M , M[A,a] : 是X的产生式, pop() , 产生式倒序入栈M[A,a] : 出错, 调用错误恢复程序构造预测分析表注意是\\alpha的First不是\\alpha的第一个符号的First对每个产生式 A\\rightarrow\\alpha1. if (FIRST(α))无空  for (a : FIRST(α)) M[A, a] := A\\rightarrow\\alpha 2. if (FIRST(α))有空  for (b : FOLLOW(A)) M[A, b] := A\\rightarrow\\alpha二步添项可能和第一步产生移进归约冲突构造分析FIRST 右边的first集的终结符 可以用左边的非终结符推出 所以 分析树可以按这个文法展开FOLLOW  如果能推出空, 后面跟着它父节点的FOLLOW集, 说明应该用它推出空这条文法, 它就是这棵枝最右边的节点, 应该继续看另一棵枝了二义文法分析表的某些条目会有多个定义(多重入口--冲突)表项唯一就是LL(1)文法预测分析的错误分析(考试不考)1.11. 自下而上分析(语法分析途径之二)最右推导的逆过程最左推导建立分析树(自上而下)归约移进-归约分析: 分析树构造(为输入串)开始: 叶节点前进: 朝着根节点过程: 把输入串 归约 成文法的开始符号每一步归约:右部匹配: 一个子串和某个产生式的.this左部符号代替: 用该产生式的.this最右推导的逆过程(跟踪的是): 每步都恰当地选择子串句柄性质句柄的右边仅含终结符文法二义\\rightarrow句柄不唯一非形式产生式右部匹配的子串(该句型中)归于成产生式左部---最右推导逆过程的一步更精确的定义右句型\\gamma的句柄产生式的右部\\beta\\gamma中的一个位置在这个位置可以找到\\beta归约后得到最右推导的前一个句型例S\\Rightarrow^*_{rm}\\alpha A\\omega\\Rightarrow^*_{rm}\\alpha\\beta\\omega右句型\\alpha\\beta\\omega\\ : 右句型 \\gamma句柄必是产生式的右部\\beta : 句柄\\ \\ \\ (必是产生式的右部)产生式A\\rightarrow\\beta : 产生式仅含有终结符\\omega仅含有终结符右句型最右推导可得到的句型用栈实现移进-归约分析分析器的基本动作（1）移进动作：把下一个输入符号移进栈。（2）归约动作：分析器知道句柄的右端已在栈顶，然后它确定句柄的左端在栈中的位置，再决定用什么样的非终结符代替句柄。（3）接受动作：分析器宣告分析成功。（4）报错动作：分析器发现语法错误，调用错误恢复例程[句柄总是出现在栈顶]实例1.12. LR分析器L: left 自左向右扫描R: 使用最右推导最有效的一种自下而上分析器对应着最右推导逆过程栈0, 输入....$高效的, 自上而下的, 语法分析技术, 能适用于一大类 上下文无关文法的分析r的语法是拓广前文法开始文法是1开始&nbsp;活前缀文法G的活前缀是他的右句型的前缀, 该前缀不超过该右句型的最右句柄的右端活前缀的右端加上一些终结符后可以使它成为右句型因此只要输入串的已扫描部分可以归约成一个活前缀, 就意味着已经扫描的部分没有错误LR分析栈中的文法符号总是构成活前缀例看他是不是活前缀,就看最后一个字符之前的东西有没有应该归约的却没归约,有的话就不是S→AdBA→a|εB→b|Bdb|εAdbd   b会被规约不是活前缀AbDd b会被规约不是活前缀AdBd AdBd  B→Bdb，还差个b才会被规约  正确ADBD AD这个组合肯定不会被规约，不存在，肯定不是活前缀 LR文法和LR分析方法的特点如果能为它构造出所有条目都唯一的LR分析表, 就说它是LR文法栈顶的状态符号包含了确定句柄所需要的一切信息另一个信息源是剩余输入的前k个符号富有吸引力原因被构造用来识别所有能用上下文无关文法写出的编程语言构造已知的最一般的移进-归约方法能分析的文法类是预测分析法(LL方法能分析的文法类)的真超集自左向右扫描的前提下, LR 能尽可能快的发现语法错误识别方式必须看见一个产生式右部推出的所有东西   并   加上k个向前搜索符号 后 才能识别该右部的出现而LL(k) 看见产生式右部推出的前k个符号时就确定使用该产生式所以LR适用更多语言1.12.1. 构造SLR(1)分析表简单的LR方法, 简称SLR方法SLR,LR,LALR的区别及判断方法DFA状态是否有冲突(移进归约,归约归约)分析表表项项目LR(0)LR(0)项目是在其右部的某个地方加点的产生式点: 点的左边代表历史信息, 右边代表展望信息LR(0)项目集的规范族所有项目按一定方法组成集合, 集合对应SLR分析器的状态, 也是DFA的状态, 这样的一族项目集就是I_0从拓广出来的那个文法算闭包,不一定有所有的文法主要思想首先从文法构造识别文法活前缀的DFA构造项目集规则其实就是求闭包函数 closure如果/是文法G的一个项目集，那么 closure（是用下面两条规则从I构造的项目集（1）初始时，的每个项目都加入 closure(I)。（2）如果A→α·B\\beta在 closure（I）中，且B→γ是产生式，那么如果项目B→·γ还不在co sure（I）中的话，则把它加入。运用这条规则，直到没有更多的项目可加入 closure（I）为止。第二条解释: 下一步从输入中可能看到的是B\\beta推出的串, B\\rightarrow\\gamma, 所以可以认为首先看到的可以是  \\gamma   推出的串, 所以把  B\\rightarrow\\cdot\\gamma  加入  closure(I)例拓广文法 : E'\\rightarrow E&nbsp;有效的如果S'\\Rightarrow_{rm}*\\alpha A \\omega\\Rightarrow_{rm}\\alpha\\beta_1\\beta_2\\omega，则说项目A\\rightarrow\\beta_1\\cdot\\beta_2对活前缀\\alpha\\beta_1是有效的        因为该项目的期望部分是\\beta_1，在活前缀1右边添上\\beta_2后仍然构成活前缀，因此说该项目对\\beta_1有效。构造SLR(1)分析表注意    闭包里有需要既有移进也有归约的别忘了他们有可能产生移进归约冲突(表项有s和r),就有二义性,按照判断是否是LR文法的规则,它应该就不是LR文法如果想要继续用这个分析表,移进归约冲突的话,,比如输入ab都是归约或者引进, 就假设a优先级高,那他就是移进, b是归约 1.12.2. 构造规范的LR分析表回顾上面讲的SLR方法，如果l包含项目[A\\rightarrow\\alpha\\cdot]且a在 FOLLOW（A）中，那么状态i要求面临a时按A→\\alpha归约。但是在有些场合下，当状态i出现在栈顶活前缀\\beta\\alpha在栈中并且a是当前输入符号时，用A→alpha来归约却不合适，因为在任何右句型中，a不可能跟随在\\betaA的后面。lR(1)项目有效的LR(1)项目[A\\rightarrow \\alpha \\cdot \\beta , a]对活前缀\\gamma有效, 如果存在推导S\\Rightarrow_{rm}*\\delta A \\omega\\Rightarrow_{rm}\\delta  \\beta \\omega, (1), \\gamma =\\delta  \\alpha是的第一个符号或者是且是(2), \\alpha 是 \\omega 的第一个符号, 或者\\omega是 \\varepsilon 且a是\\$算法   1.12.3. 构造LALR分析表做法寻找同心的LR(1)项目集, 即略去搜索符后它们是相同的集合，并把这些同心集合并成一个项目集。冲突&emsp; &emsp; 不会带来新的移进-归约冲突 &emsp; &emsp; 可能会出现归约-归约冲突&emsp; &emsp; &emsp; 如果归约-归约冲突就不是LALR(1) 只是LR(1)的特点当输入串有错误时，LALR分析可能比LR分析多做了一些不必要的归约，但LALR分析决不会比LR分析移进更多的符号。即就准确地指出输入串的出错位置而言，LALR分析和LR分析是等效的1.12.4. 非二义且非LR的上下文无关文法若自左向右扫描的移进-归约分析器能及时识别出现在栈顶的句柄那么相应的文法就是LR的。而二义文法一定不是LR的","tags":["编译原理"],"categories":["编译原理"]},{"title":"1_词法分析","url":"/2020/01/13/1_词法分析/","content":"&nbsp;1. 绪论1.1. 识别过程词法-语法-语义(分析)-中间代码生成-可执行代码1.2. 编译器构造与分析集成开发环境编辑器源程序编译器可执行程序解释器可执行程序操作系统\\rightarrow [集成开发环境(编辑器\\overset{源程序}{\\rightarrow }编译器)]\\left\\{\\begin{matrix}\\overset{可执行程序.exe}{\\rightarrow }\\\\\\rightarrow 解释器\\overset{可执行程序.exe}{\\rightarrow }\\end{matrix}\\right. 操作系统1.3. 前端后端前端 只依赖源程序独立于目标机器(生成中间代码)后端与源程序无关依赖于目标机器有关: (只)中间语言(中间代码\\rightarrow目标代码)好处提高开发编译器效率前端重用重写后端&nbsp;1.4. 翻译器源语言\\rightarrow目标语言1.5. 编译器一种翻译器目标语言比源语言更低级处理编程语言(机器, 汇编, 高级)2. 词法分析器识别单词源程序\\rightarrow词法记号(token)流  (记号名,属性值)-区分标识符\\ \\   符号表放id  和用户接口的一些任务输出: 单词种别编码 和 单词属性值2.1. 词法单元单词编程语言中合法的字符串2.2. 词法记号词法单元 \\rightarrow满足给定规则 \\rightarrow词法记号2.2.1. 属性词法记号具有一定含义2.2.2. 串和语言2.3. 词法记号识别对字符串的匹配可以基于有限状态机2.3.1. 有限状态机2.3.1.1. 确定的有限自动机(DFA)状态集合S输入字母表 \\Sigma转换函数 move: S\\times\\Sigma\\rightarrow S唯一的初态 s\\in S终态集合 F\\subseteq S2.3.1.2. 不确定的有限自动机(NFA)状态集合S输入字母表 \\Sigma转换函数 move: S\\times\\{\\Sigma\\cup\\{\\epsilon\\}\\}\\rightarrow P\\{S\\}唯一的初态 s\\in S终态集合 F\\subseteq S2.3.1.3. DFA构建自然语言 \\rightarrow DFA正规式 \\rightarrow DFA\\先画出主要的一条通路然后补成全函数,看遇到输入跳转到哪个状态 (a|b)^*a正规式 \\rightarrow NFA \\rightarrow DFA    NFA构建识别 \\epsilon 和 字母表符号的 NFA识别 选择识别 连接识别 闭包NFA \\rightarrowDFA转化子集构造法开始符号不用任何输入(\\epsilon)能到的状态算一堆遇到每个输入整一个状态--画表没有对某个输入的转换那就空着DFA化简(正规集表示: 唯一 状态最少 DFA 识别)(状态分成不相交的子集)添加死状态S_d,所有输入转换到S_d本身 \\rightarrow 全函数宗旨:一个集合遇到输入分到一个集合的子集就是一起的,如果分到其他集合去了,就把它划分出去(1) 接受状态和非接受状态 (\\epsilon可判断) \\rightarrow 初始划分 \\prod(2) 中的每个子集for(\\prod中的每个子集G)\\{&emsp; &emsp; &emsp; 划分子集对于任意输入转换到的同一子集划分子集G: 对于任意输入a, 转换到\\prod的同一子集&emsp; &emsp; &emsp; 中用的划分代替\\prod_{new}中用G的划分代替G\\ \\ \\} (3) if (\\prod_{new}=\\prod) \\prod_{final}=\\prod\\rightarrow(4) else \\prod=\\prod_{new}\\rightarrow (2)(4) 状态子集选一个代表\\prod_{final} 状态子集选一个代表(5) if (M' 有死状态) 去掉  &emsp; &emsp; 开始状态不可达的删除&emsp; &emsp; 到死状态的转换改成无定义2.4. 正规式存在一个DFA接受这个语言:正规语言按照一组定义规则由简单正规式构成正规式r表示语言L(r)表示简单的语言\\rightarrow正规集正规式等价: 识别的语言集相等2.5. 词法模式给定规则2.6. 词法错误2.6.1. 恢复策略紧急恢复错误修补尝试删多余字符插入遗漏字符正确字符代替交换相邻字符","categories":["编译原理"]},{"title":"密码学","url":"/2020/01/13/密码学/","content":"第一章安全攻击对任何机构信息资源破坏的行为被动攻击泄露流量分析主动攻击伪装重放信息修改拒绝服务安全机制检测.防止安全攻击/或攻击中恢复需多种机制合作重要机制之一: 密码编码体制第二章传统加密技术密码一组含有参数K的变换E理论安全一次一密  :  密钥长度\\geq密文长度  不实用  大规模随机密钥产生困难/密钥分配和保护困难实际安全有限资源范围内, 破译系统计算上不可行  (通过系统的分析)密码体制:  基本要素 : 密码算法  /  密钥序列密码有关: 算法 / 密钥 / 明文位置   单位: 明文比特伪随机序列&amp;明文序列 mod 2 加  --&gt;密文序列分组密码有关: 算法 / 密钥单位: \\geq64bit 数据块相同长度密文现代密码学基本原则公开算法保密密钥  (系统的安全性在于此)加密算法基于原理代替  :  明文元素映射另一元素置换  :  明文元素重新排列第四章数论最大公因子gcd(a,b) = gck(|a|,|b|)\\\\gcd(a,0) = a同余的性质那么n|(a-b),那么a \\equiv b(a,b)求解单变量线性同余方程:模运算的性质剩余集模的剩余类与互素因为与互素在中存在乘法逆元两边就消掉了\\begin{aligned}&剩余集(模n的剩余类) : Z_n=\\{0,1,\\cdot\\cdot\\cdot,n-1\\}\\\\&(a+b)\\equiv (a+c)(mod\\ n) \\rightarrow b \\equiv c (mod\\ n)\\\\&a与n互素,(a\\times b)\\equiv (a\\times c)(mod\\ n)\\rightarrow b \\equiv c (mod\\ n)\\\\&因为a与n互素,a在Z_n中存在乘法逆元,两边×a^{-1}就消掉了\\end{aligned}Euclid算法任意非负整数任意正整数任意非负整数a,任意正整数b\\\\gcd (a,b) =gcd (b,a\\ mod\\ b)扩展的Euclid算法   ax + by = d = gcd (a,b)群环域群加法 封闭 结合加法 两元加法 交换律 -&gt; 交换群环乘法 封闭 结合 分配乘法 交换律 -&gt; 可交换环乘法 单位元 + 无零因子(ab=0,ab都=0) -&gt; 整环域乘法逆元有限域GF(p)不加附加条件就可以是素数肯定有逆元不加附加条件就可以 (a\\times b)\\equiv (a\\times c) (mod\\ p)\\rightarrow b \\equiv c (mod\\ p)\\\\p是素数,a肯定有逆元\\\\((a^{-1})\\times a\\times b)\\equiv((a^{-1})\\times a\\times c)(mod\\ p)\\rightarrow b\\equiv c(mod\\ p)在GF(p)中求乘法逆元和互素有模的乘法逆元a和b互素 \\rightarrow  b有模a的乘法逆元\\\\ax + by = d = gcd (a,b) = 1\\\\y = b ^{-1}有限域GF(p ^{n})有限域的阶必须是一个素数的幂代表域\\begin{aligned}&有限域的阶p ^{n}必须是一个素数的幂p ^{n} \\ GF代表Galois域\\end{aligned}参考模运算的性质第六章分组密码的工作模式乘积密码混淆 :  密文 密钥 关系复杂扩散 :  明文 密文 统计关系尽量复杂DES是应用最为广泛的分组密码扩展了Feistel结构 (基于可逆乘积加密器)  分组(64位) 密钥(56位)双重DES解密时逆序使用密钥付出的是2^{56}数量级的,比攻击单DES的2^{55}数量级多不了多少中途相遇攻击不依赖于DES的任何特殊性质,对所有分组密码都有效&nbsp;分组密码5种工作模式增强密码算法/使算法适应具体应用的技术            模式        描述        典型应用        缺点        优点            ECB(Electronic code Book)电码本    相同的Key加密每一组    数据较少-加密DES或AES密匙    很长的消息,ECB可能不安全,利用规律性特征        CBC(Cipher Block Chaining)密文分组链接    输入时当前明文组+上一个密文组的异或(IV-ECB加密发送)密钥是相同的    面向分组的通用传输认证    不能明文传送IV解密IV不能扩散        CFB(Cipher Feedback)密文反馈模式    可将分组密码当作流密码,可以实时操作,密文与明文等长,加解密使用同一函数,一次处理s位,上一块密文作为加密算法的输入,产生的伪随机数输出与明文异或作为下一单元的密文,与明文异或的位流是与明文相关的    面向数据流的通用传输认证        可以作为流密码或者分组密码流密码不用填充实时操作密文与明文等长        OFB(Output Feedback)输出反馈模式    加密算法的输入是上一次加密的输出，且使用整个分组,在某位上发生的错误不会影响到其他位    噪声信道上的数据流的传输(如卫星通信)    抗消息篡改的能力不如CFB,控制对恢复明文的改变,改动校验和不被发现(密文的某位取反,明文相应位取反)      传输过程某些位的错误不会影响其他位        CTR(Counter)计数器模式    每个明文分组都与一个经过加密的计数器相异或.对后续分组计数器递增    用于高速需求并行加密对被加密的分组进行随机存取简洁安全不用填充分组          1.硬件: 并行处理2.软件: 并行计算3.预处理: 算法执行不依赖与明密文的输入4.随机访问: 破解其中一部分5.安全6.简单: 值用加密算法  第八章数论定理描述内容费马定理素数和互素等价形式素数任意正整数\\begin{aligned} \\\\ &{\\color{red}素数p,a和p互素} \\\\ &a ^{p-1}\\equiv 1(mod\\ p) \\\\&{\\color{blue}等价形式}\\\\ &素数p,a{\\color{red}任意正整数} \\\\ &a ^{p} \\equiv a(mod\\ p) \\end{aligned}小于的正整数集合乘所有元素对取模与互素所以的元素不等零不整除且不相等假设互素消掉不可能所以两集合构成相同顺序不同和互素消去 \\begin{aligned}&小于p的正整数集合\\{1,2...p-1\\}\\\\&a乘所有元素对p取模\\\\&X=\\{a\\ mod\\ p,2a\\ mod\\ p,...(p-1)\\ mod\\ p\\}\\\\&a与p互素\\\\&所以X的元素不等零(p不整除a)且不相等(\\\\&假设ja\\equiv ka(mod\\ p)\\\\&ap互素消掉a\\rightarrow j\\equiv k(mod\\ p),不可能)\\\\&所以两集合构成相同(顺序不同)\\\\&a\\times2a\\times..\\times(p-1)\\equiv[1\\times2\\times...\\times(p-1)](mod\\ p)\\\\&a^{p-1}(p-1)!\\equiv(p-1)!(mod\\ p)\\\\&(p-1)!和p互素,消去(p-1)!\\\\&a^{p-1}\\equiv 1(mod\\ p)\\end{aligned}欧拉函数 \\phi(n)小于n且与n互素的正整数的个数对于素数对于两个素数和\\begin{aligned} &对于素数p \\\\&\\phi (p) = p -1 \\\\&对于两个素数p和q \\\\&p!=q\\\\&\\phi (n) = \\phi (pq)=\\phi (p) \\times \\phi (q) = (p - 1) \\times (q - 1) \\end{aligned}欧拉定理&nbsp;和互素\\begin{aligned} &{\\color{red}a和n互素} \\\\ &a^{\\phi (n)}\\equiv 1 (mod \\ n) \\\\ &a ^{\\phi (n)+1}\\equiv a(mod \\ n) \\end{aligned}中国剩余定理说明某一范围内的整数可通过他对两两互素的整数取模所得的余数来重构(用途之一:使得模M的大数运算转换到更小的数上运算)断言一: 0\\leq A\\leq M   A有为一k元组(a_1,a_2,...,a_k)与之对应,0\\leq a_i\\leq m_i断言二: 若则和类似若\\\\A\\leftrightarrow(a_1,a_2...a_k)\\\\B\\leftrightarrow(b_1,b_2...b_k)\\\\则\\\\ (A+B)mod\\ M\\leftrightarrow((a_1+a_2)mod\\ M...),\\\\-和\\times类似两两互素有整数解模有唯一整数解其中\\begin{aligned} &m_1,m_2,...m_3两两互素\\\\&x\\equiv a_1(mod\\ m_1)\\\\&x\\equiv a_2(mod\\ m_2)\\\\&x\\equiv a_3(mod\\ m_3)\\\\&.\\\\&.\\\\&.\\\\&x\\equiv a_k(mod\\ m_k)\\\\&有整数解.\\\\&模M=m_1\\cdot m_2\\cdot ...\\cdot\\  m_k有唯一整数解\\\\&x\\equiv(a_1M_1(M_1^{-1}mod\\ m_1)+a_2M_2(M_2^{-1}mod\\ m_2)+\\\\&\\ \\ \\ \\ ...+a_kM_k(M_k^{-1}mod\\ m_k)(mod M)\\\\&其中M_i=M/m_i\\end{aligned}费马定理欧拉函数欧拉定理第九章非对称密码公开密钥密码体制对称密码体制问题加解密能力捆绑密钥需可靠信道/分发困难密钥多/管理困难不认识的人无法不能数字签名&nbsp;&nbsp;&nbsp;非对称密码体制特点加解密能力分开密钥分发简单密钥少不认识的人可以数字签名&nbsp;&nbsp;算法特点密码算法+公钥(不能)私钥两个密钥一个加密一个解密都行&nbsp;&nbsp;应用加解密数字签名密钥交换&nbsp;&nbsp;攻击方法容易穷举\\rightarrow长密钥从公钥算出私钥穷举消息攻击/对可能消息加密与密文比对体制特点公开密钥密码体制根据密码算法&amp;密钥确定解密密钥在计算上是不可行的两个密钥的任何一个都可以用来加密,另一个用来解密RSA算法基于大合数的质因子分解问题的困难性&nbsp;算法流程秘密大素数p/q\\rightarrow公开模数n=p*q\\rightarrow秘密的\\varphi(n)=(p-1)(q-1)\\rightarrow选一个与\\varphi(n)互素的eM\\in[0,n-1]ed\\ mod\\ \\varphi(n)=1,求d加密:C=M^{e}mod\\ n解密:M=C^{d}mod\\ n=(M^{e}mod\\ n)^{d}mod\\ n=M公钥PU{e,n}/私钥PR{d,n}&nbsp;攻击方法强行攻击:尝试所有密钥数学攻击:分解出出p和q(FAC问题)计时攻击:依赖于解密算法的运行时间RSA算法证明第十章密钥管理分发方式内容缺陷公钥的公开发布发送/广播伪造公钥,冒充其他人公开可访问的目录{姓名,公钥}目录管理员注册(安全方式)用户可以在任何时刻更新密钥通信方可访问该目录获取目录管理员密钥冒充任何通信方或者更改目录记录公钥授权私钥加密: 来自管理员原式请求: 请求未被篡改时间戳: 不是重放N_1,N_2: 彼此确认身份&nbsp;公钥证书时间戳: 验证证书的时效性           挂失&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密钥交换Diffie-Hellman\\\\密钥交换有效性计算离散对数很困难&nbsp;&nbsp;离散对数问题本原根产生模的完全剩余集任意整数所有素数本原根必存在a^{n}\\ mod\\ p,产生模p的完全剩余集,\\\\任意整数b,b\\equiv a^{i}(mod\\ p)\\ \\\\(0\\leqslant i\\leqslant (p-1))\\\\所有素数,本原根必存在&nbsp;DLP问题离散对数问题Discrete Logarithm  Problem已知和难以计算已知C和P\\\\难以计算\\\\d=\\log_c^Min\\ GF(P)&nbsp;&nbsp;算法素数是的原根选择秘密钥计算公钥计算会话密钥或者{\\color{red}素数q,\\alpha 是q的原根}\\\\选择秘密钥x_A,x_B\\\\计算公钥y_A=\\alpha^{X_A},y_B=\\alpha^{X_B}\\\\计算会话密钥K_{AB}=y_{A}^{x_{B}}\\ mod\\ p\\\\或者K_{AB}=y_{B}^{x_{A}}\\ mod\\ p&nbsp;密码体系ElGamal密码体系基于DLP的概率密码系统&nbsp;&nbsp;算法加密素数是的原根选择找到公钥计算密文{\\color{red}素数q,\\alpha 是q的原根}\\\\A选择 {\\color{red}k\\in [1,p-1]}\\\\找到B公钥Y_B=\\alpha^{x_{B}}mod\\ p\\\\计算K=(Y_{B})^{k}mod\\ p\\\\0\\leq m\\leq q-1 \\\\c_{1}=\\alpha ^{k}mod\\ p\\\\c_{2}=mK\\ mod\\ p\\\\密文:(c_{1},c_{2})&nbsp;&nbsp;解密恢复然后恢复B恢复K:K=c_{1}^{x_{B}}mod\\ p\\\\然后恢复m:m=c_{2}/K\\ mod\\ p&nbsp;注意:k不能重复使用已知可推出c_{11}=\\alpha^{k}mod\\ p,\\\\c_{21}=m_1K\\ mod\\ p\\\\c_{12}=\\alpha^{k}mod\\ p\\\\c_{22}=m_2K\\ mod\\ p\\\\m_1/m_2=c_{21}/c_{22}\\ mod\\ p\\\\m_1已知可推出m_2&nbsp;Deffie-Hellman中间人攻击第十一章消息认证&nbsp;&nbsp;&nbsp;&nbsp;消息认证消息认证验证消息完整性的(机制)(服务):收到的和发送的消息一样/发送方声称的身份是真实有效的​&nbsp;&nbsp;&nbsp;关心的问题保护消息的完整性​验证发起方身份​消息源的不可否认(解决分歧)&nbsp;&nbsp;考虑安全需求(可能的攻击)1. 泄密2. 传输分析3. 伪装4. 内容修改5. 顺序修改6.计时修改(延时/重播)7. 发送方否认8. 接收方否认&nbsp;三种消息认证方法(产生认证符的函数类型)&nbsp;①消息加密消息本身认证手段消息本身\\rightarrow认证手段1 对称加密  (认证/保密)(不管密文是啥明文有合法的位模式就当成真实的密文)2 公钥加密  (认证/保密)(A私钥加密M然后B公钥加密M==数字签名)(执行四次复杂的公钥算法)解密所得消息是否具有可读性问题帧校验序列帧校验序列(F(M))奇偶校验码②消息认证码(MAC)即带密钥的Hash函数密钥和数据块作为输入,产生的Hash值作为MAC码(认证功能,其他人不知道密钥)MAC=C(K,M)计算上是不可行的分布均匀/(C(K,M)=C(K,M')计算上是不可行的)\\\\ /(C(K,M)分布均匀)\\\\/不提供数字签名(双方共享密钥)③哈希函数报文输入定长的散列码哈希函数值报文摘要报文M输入\\rightarrow定长的散列码H(M)(哈希函数值==报文摘要)(具有差错检测能力)(a)对称密码算法加密消息和Hash码(认证功能/保密性)(b)对称密码算法加密Hash码(认证功能)(c)仅使用Hash函数(共享秘密值S+M)(认证功能)(d)整个消息和Hash值加密(在c基础上(认证功能/保密性))&nbsp;消息认证使用形式&nbsp;&nbsp;相同报文进行多点广播&nbsp;&nbsp;接收方有选择的鉴别,对报文随机检查,无法对所有的报文解密&nbsp;&nbsp;对计算机程序(明文)鉴别,检查完整性&nbsp;&nbsp;鉴别报文的真实性&nbsp;&nbsp;散列函数要求&nbsp;应用于任意大小的数据块&nbsp;固定长度的输出&nbsp;x容易算H(x)=h&nbsp;h不容易算H(x)=h&nbsp;x 找到x\\neq y\\ H(x)=H(y)计算上不可行(抗弱碰撞性)&nbsp;偶对H(x)=H(y)偶对(x,y)计算上不可行(抗强碰撞性)&nbsp;第十三章数字签名&nbsp;&nbsp;&nbsp;&nbsp;数字签名起签名作用的码字&nbsp;&nbsp;&nbsp;保证了来源和完整性&nbsp;&nbsp;&nbsp;与消息认证的区别防止第三方破坏(任何其他知道改用户公钥的人都能通过数字签名来验证消息的完整性)利害关系解决纠纷&nbsp;&nbsp;安全性依赖与私有密钥的安全性&nbsp;&nbsp;基本形式两种方法1消息整体签字2对消息摘要签字&nbsp;&nbsp;两类数字签名确定性签名,明文与签名一一对应概率性数字签名,一个明文多个合法签名,每次不同&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接数字签名仅涉及(信源/信宿)可以说私钥丢了别人发的(加时间戳;泄密后应立即向管理中心报告)(但是可以加盖T之前的时间戳)解决: 使用数字证书管理中心(CA)仲裁数字签名1签名报文给仲裁者2仲裁者检验出处内容/注上日期/仲裁说明\\rightarrow接收方&nbsp;要求:仲裁方一定程度可信任使用对称或公开密钥实现仲裁方可以知道或不知道消息&nbsp;&nbsp;&nbsp;ElGamal的数字签名方法产生公钥/私钥对随机整数私公1.随机整数X_A,(1&nbsp;产生数字签名素数是的原根随机签名{\\color{red}素数q,\\alpha 是q的原根}\\\\0.m=H(M),(0\\leqslant m\\leqslant q-1)\\\\1.随机{\\color{red}K\\in[1,q-1],gcd(K,q-1)=1}\\\\2.S_1=\\alpha^{K}mod\\ q\\\\3.K^{-1}mod{\\color{red}(q-1)}\\\\4.S_2=K^{-1}(m-X_AS_1)mod\\ {\\color{red}(q-1)}\\\\5.签名(S_1,S_2)&nbsp;验证则合法V_1=\\alpha ^mmod\\ q\\\\V_2=(Y_A)^{S_{1}}(S_1)^{S_2}mod\\ q\\\\V_1=V_2则合法&nbsp;预先使用哈希函数缩小签名密文的长度,加快数字签名和验证签名的运算速度第十五章用户认证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;认证服务功能信息真实性存储数据的真实性接收方提供回执不可否认时效性/公证可能性(身份认证)&amp;(消息认证)&nbsp;目的放窃听/假冒/拦截/窃取&nbsp;&nbsp;基本认证方法单向认证对称加密(一次一密变形)公开密钥(B给A随机数他用私钥加密发回来)改进的口令方式&nbsp;&nbsp;双向认证关注的问题:(保密性/时效性)对称密钥(三次握手)公开密钥(A,B使用不同的R值)&nbsp;&nbsp;&nbsp;重放攻击(合法签名消息拷贝重新发)解决: 序列号        时间戳        挑战/应答(消息附加临时交互号(询问),回复中包含临时交互号)&nbsp;&nbsp;可信中继使用KDC密钥分发中心通过DASS群认证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对称加密方法1.每方与KDC共享主密钥2.KDC产生双方通信会话密钥3.用主密钥分发会话密钥&nbsp;&nbsp;&nbsp;第十四章Kerberos&nbsp;&nbsp;&nbsp;Kerberos用于分布式环境下的认证服务利用可信的第三方&nbsp;&nbsp;Kerberos动机保护用户信息和服务器资源,要求客服向服务器提供身份认证,服务器向客服提供身份认证&nbsp;Kerberos使用模式(主体是Cilent/Server)服务器: 提供识别服务的Kerberos服务器/应用服务的其他服务器1. 用户/服务器到Kerberos服务器注册(实现秘密共享)2. 识别过程中K服务器为双方建立一个通信密钥&nbsp;方法使用中央式的识别服务器(Authentication Server,AS)为用户服务器提供识别服务AS与用户共享口令与其他服务器共享密钥注册时分配个各方&nbsp;&nbsp;&nbsp;","tags":["概述","密码学"],"categories":["密码学","概述"]},{"title":"软件工程概述","url":"/2020/01/12/软件工程概述/","content":"1. 软件工程概述软件: 程序:指令集数据. 文档: 研制过程/方法/使用 的记录软件危机开发,维护$\\rightarrow$严重问题$\\rightarrow$软件寿命缩短/夭折表现预算/成本 没钱期限/进度 干不完质量 干的差用户满意 让人骂开发过程.有效介入.管理 干的乱七八糟代码维护    代码是一坨屎,不会磨损,但会退化原因技术    干活的不行规模复杂(固有)管理 管人的不行无理论指导.靠个人技巧 瞎bb用户需求完整准确认识 啥也不懂消除方式正确认识软件成功的更好的技术/方法/消除概念/做法软件工具(开发/使用)管理措施(时间/人员/资源)软件工程研究方面(技术/管理)无章法(个人英雄)$\\rightarrow$工程项目管理模式(团队)[IEEE](工程原则/方法)系统/规范/可量化$\\overset{应用于}{\\rightarrow}$开发/运行/维护/方法的理论研究目标   (高/低)(高效开发)高质量软件(降低开发)成本基本原理1.分阶段/生命周期计划/严格管理2.坚持/阶段评审3.严格/产品控制4.现代/程序设计技术5.结果/能/清楚审查6.开发小组/少/精7.承认/不断/改进/软件工程实践/必要性系统工程目的(更好)达到(系统目标)/对系统的(构成要素)(组织结构)(信息流动)(控制机构)/分析/设计正确的/时间/方法/事情实现方法商业过程工程(Business Process Engineering)产品工程(Product Engineering)常用方法层次分析方法/分解为不同的(组成因素)/关联影响.隶属关系/不同层次组合统一建模语言UML(Unified Model Language)描述OO开发中占主导地位提供整套系统建模的基础设施:模型表示/建模 软件开发中的(语言表示)与(过程)分离功能可视化 规格说明    构造 文档化   2.0模型用例系统&amp;使用者活动顺序&amp;并行活动类类&amp;接口&amp;关系对象顺序对象的互动顺序通信对象的交互方法&amp;需要支持交互的连接时序重点对象交互时间安排交互概况组成结构组件包类&amp;组件的分级组织状态生命周期对象的状态&amp;事件部署系统开发的解空间现代的面向对象分析和设计方法是(基于模型)综合使用/用例建模/静态建模/动态建模/构建建模/描述/软件需求,分析/设计模型 软件工程开发方法技术/规范三个要素  方法/工具/过程传统(结构化)方法静态的思想分而治之若干阶段/阶段任务/阶段顺序 好多阶段干啥,谁先干缺点灵活性应对无法避免未预料变化(软件规模大/早期需求模糊/常变)不成功/维护困难/系统总成本 面向对象方法动态的思想模拟人类思维对象(静态属性/动态方法) 作为 (融合数据&amp;数据之上的操作行为的统一)软件构件 对象对象划分为(类:静态属性/动态方法) 对象咋样类s构成(继承)层次关系 好多对象(消息机制)联系-封装性 对象交流特点模拟人类思维主动反复迭代过程概念表示一致阶段过渡平滑无缝继承降复杂重用2. 软件开发过程/软件开发生命周期软件开发 (宏观上)任务框架/规范软件生命周期模型种类顺序式迭代式增量式敏捷式过程管理(划分软件生命周期)分而治之软件定义(时期)具体阶段/对应/明确任务软件开发(时期)具体阶段/对应/明确任务运行维护(时期)具体阶段/对应/明确任务更加细分软件生命周期1.可行性分析与开发设计尽快确定能否开发,是否值得开发的依据-可行性报告解决办法(技术/经济/社会可行性)2.需求分析未来需要完成的功能详细分析-需求规格报告基础成功与否需求变更管理3.软件设计需求系统求解的框架:架构/数据设计…1. 概要设计-概要设计说明书2. 详细设计-详细设计说明书蓝图-未来扩展/稳定性4.编码软件设计结果$\\overset{翻译}{\\rightarrow}$程序代码5.软件测试单元测试集成测试系统测试黑盒/白盒6.软件维护持续时间最长持续适应要求延续寿命传统生命周期模型:严格按照 需求,分析, 设计, 编码, 维护最基本和有效传统生命周期模型顺序式瀑布模型最广泛特点文档/计划驱动(静态的开发形式)阶段顺序 按攻略推迟实现/对系统充分认识理解 整明白再干质量保证(阶段结束前的评审)延迟处理 靠开发者的谱问题用户/早期结束接触/开发者臆想/系统返工 不靠用户的谱灵活性/变更 不希望有变化应用规模较大(系统开发)/分布式(开发模式)-系统的整体把控&amp;协调顺序式快速原型模型特点用户与开发者(桥梁)对系统快速简单分析$\\rightarrow$软件原型 需求阶段产生试用演示原型/沟通反馈/评价改进/误解/需求不明确风险/提高质量/真正需求适用全新系统开发/原型$\\rightarrow$开发方向正确性尝试运用未来系统中需要的新技术,提前测试性能上要求主要问题选用的(开发技术/工具)实际不一定需要快速建立的模型不符合各种开发规范/不断修改$\\rightarrow$质量差/完全抛弃增量式增量(演化)模型特点软件(视为)一系列(增量构件)-设计/实现/继承/测试构件-代码片段-特定功能-互相作用的模块第一个增量(基本需求的核心产品)/评估/下一个增量不足加入构件不能破坏系统部分/需要开放式体系结构灵活性-容易退化成边做边改-软件过程的控制整体性迭代式螺旋模型特点结合瀑布&amp;快速原型风险驱动(可选方案&amp;约束条件:-软件重用) - 每个阶段都有风险分析使用原型/其他方法/降低风险适用大型复杂(系统开发)限制客户难理解风险分析/内部的大规模开发风险分析影响利润-大项目准确分析风险/否则/更大的风险缺点有些风险无能为力需要专业风险评估人员迭代式喷泉模型(典型的)面向对象生命周期模型具有更多增量和迭代性质各生存期可以嵌入子生存期优势体现(面向对象软件开发)迭代/无缝(分析到设计的转化/局部的优化)避免无序$\\rightarrow$(线性过程)(作为总目标)敏捷生命周期模型敏捷宣言个体/互动$\\overset{胜过}{\\rightarrow}$流程/工具 人工作的软件$\\overset{胜过}{\\rightarrow}$详尽的文档 show code客户合作$\\overset{胜过}{\\rightarrow}$合同谈判 听人话响应变化$\\overset{胜过}{\\rightarrow}$遵循计划 机灵特点增量交付分批分期交付用户产品/软件产品外的不确定因素实现必要的用例(软件的价值)-功能细化迭代开发先构建后修改/对方案不断提升优化优势精确/质量/速度:较大前期规划/关注当前/丰厚的投资回报率/高效的自我管理团队适合规模中小/需求变化频繁/强调团队/集中式的开发模式极限编程eXtrame Programing目的降低(需求变化)成本崇尚客户和开发团队融合结对编程开发流程编写用例、架构规范、实施规划、迭代计划、代码开发、单元测试、验收测试积极接受变化价值观与原则互动交流(文档不是必须的)反馈简单勇气团队核心做法规模小发布版本频繁迭代周期短测试驱动结对编程每日站立会议共同拥有代码持续集成系统隐喻SCRUM过程敏捷(混乱)开发框架注重软件开发的系统化过程,XP注重实践需求被定义为 产品需求积压(用例/功能描述/技术要求…)开发过程分为多个Sprint冲刺周期(1~4周的开发周期)有限安排重要产品需求积压到下一个SprintDaily Scrum Meeting-进展&amp;障碍Sprint Review Sprint评审会议-给客户看-Sprint Retrospective回顾会议-改进&amp;肯定burn down 燃尽图(公开图表):当前冲刺未完成的数目SCRUM角色产品拥有者远景规划平衡利益确定产品积压的优先级…联络点(开发团队&amp;客户)涉众(利益相关者)客户代表收集编写产品需求审查专家指导联络点(开发团队&amp;产品拥有者)团队成员开发人员DevOps过程Development&amp;Operation开发运维源于敏捷开发遵从敏捷宣言不限于某种软件开发过过程 瀑布都能用强调开发和运维 紧密协作部门: 开发&amp;技术运营&amp;质量保障核心目标自动化”软件交付”&amp;”架构变更”可持续交付实现生命周期的工具全链路打通&amp;自动化跨团队线上协作提高生产环境可靠/稳定/弹性/安全3. 需求分析需求分析:软件开发的第一个阶段需求分析活动部分内容需求准备通过(需求规格说明书)描述项目应该实现的内容需求分析的开始阶段(可行性分析)可行性分析:明确(功能性需求/边界位置/在技术,经济,法律,操作方面项目是否可行,给出解决方案)系统涉众(Stakeholder)(利益相关者)与目系统相关的一切人和物系统目标涉众提供了目标/目标影响对涉众的取舍用于软件验收依据软件设计依据用户开发者共同理解软件要做什么用例与系统功能部分定义类型用例使用一种交互的方式来描述系统的场景借以捕获用户的需求识别角色系统边界外 Actor(角色) 用例提炼包含关系通用过程的定义-&gt;为主用例提供基础性功能  间接服务&lt;&lt;include&gt;&gt;&lt;&lt;secondary&gt;&gt;员工数据维护/工作状态更新–&gt;系统登录扩展关系某些情况下强烈表达的一种意愿,一般备选事件流直接服务&lt;&lt;extend&gt;&gt;项目状态分析&lt;–项目警告活动图处理流程–事件流数据流图DFD描绘信息流&amp;数据变换(输入移动到输出)系统的逻辑模型分析和设计的工具  成分 源点/终点处理数据存储数据流信息流交换流事务流4. 软件构架的构建也称为软件体系结构好处 :  对软件构架的系统, 深入的研究$\\rightarrow$提高软件生产率/解决软件维护问题  的  新途径理解定义软件架构设计:  建立系统所需的(数据结构)&amp;(程序构件)考虑:         - 体系结构风格         - 组成构件的结构&amp;属性         - 所有体系结构构件之间的相互关系为系统提供结构/行为/属性的高级抽象,由构成系统的元素的描述,元素的相互作用,指导元素集成的模式,模式的约束组成指定了系统的组织结构/拓扑结构,显示了系统需求.构成系统的元素之间的对应关系提供了一些决策的基本原理软件架构的5种模型(根据侧重点不同)结构模型框架模型动态模型过程模型功能模型软件架构的 “4+1”模型将五种模型有机的统一,形成完整的模型从五个不同的角度描述软件架构每个视图只关心系统的一个侧面,五个视图结合在一起才能反应系统的软件架构的全部内容软件架构的基本元素五种元素则称体系结构的核心模型构件: 具有某种功能的可重用的软件模板单元,表示了系统中主要的计算元素和数据存储复合构件原子构件连接件: 构件之间的交互简单的: 管道(Pipe),过程调用(Procedure call), 事件广播(Event broadcast)等复杂的: 客户/服务器(Client/Server)通信协议、数据库和应用之间的SQL连接等配置: 表示了构件和连接件的拓扑逻辑和约束其他非基本端口(Port)角色(Role)软件架构风格软件架构设计的一个核心问题是能否使用重复的体系结构模式，即能否达到体系结构级的软件重用。软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式。定义了一个系统家族，包括体系结构的定义、词汇表和一组约束。定义了用于描述系统的术语表和一组指导构建系统的规则。软件架构风格促进了对设计的重用，不变的部分使不同的系统可以共享同一实现代码，只要系统是使用常用的、规范的方法来组织，就可使别的设计师很容易地理解系统的体系结构。通用体系结构的分类数据流风格：批处理序列、管道与过滤器等。调用/返回风格：层次结构、正交软件结构、客户机/服务器结构、浏览器/服务器结构等。独立构件风格：进程通信、事件系统、MVC结构等。虚拟机风格：解释器、基于规则的系统等。数据中心风格：数据库系统、超文本系统、仓库/黑板系统等。管道与过滤器(数据流风格)• 每个构件都有一组输入和输出，构件读取输入的数据流，经过内部处理，然后产生输出数据流。• 构件被称为过滤器，这种风格的连接件就是数据流传输的管道，将一个过滤器的输出传到另一过滤器的    输入。• 过滤器是独立的实体，不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。应用:适合批处理和非交互处理的系统，使软件具有良好的信息隐藏性和模块独立性，从而产生高内聚、低耦合的特点。层次系统(调用返回风格)• 层次系统中，每一层为上层提供服务，并作为其下层客户。• 连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束。• 这种风格支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。仓库/黑板系统(数据中心风格)• 两种不同的构件,中央数据结构说明当前状态，独立构件在中央数据存储上执行. 仓库与外构件间的相互作用在系统中会有较大的变化。• 控制原则的选取将产生两个主要的子类：• 黑板系统的应用 : 传统应用是信号处理领域，如语音和模式识别，另外的应用包括松耦合代理数据共享存取等。三部分组成知识源 : 包含独立的与应用程序相关的知识,知识源之间不直接进行通信,交互只通过黑板完成黑板数据结构 : 按照与应用程序相关的层次来组织的,解决问题的数据 . 知识源通过不断改变黑板数据来解决问题控制 : 完全由黑板的状态驱动, 黑板状态的改变决定知识的改变正交软件结构(调用返回风格)• 由组织层和线索的构件构成• 如果线索是相互独立的，即不同线索中的构件之间没有相互调用(即同一层级)，那么这个结构就是完全正交的。• 正交软件架构是一种以垂直线索构件族为基础的层次化结构。• 在软件演化过程中，系统需求会不断发生变化。在正交软件架构中，因线索的正交性，每个需求变动仅影响某一条线索。客户 / 服务器架构(调用返回风格)• 服务器负责管理系统资源：访问与并发性控制、安全性、备份与恢复和全局数据完整性规则。• 客户应用程序提供用户与服务器交互的界面、向服务器提交用户请求并接收来自服务器的信息、利用客户应用程序对存在于客户端的数据执行应用逻辑要求。• 网络通信软件的主要作用是完成服务器和客户应用程序之间的数据传输。• 服务器为多个客户应用程序管理数据• 对于硬件和软件的变化具有极大的适应性和灵活性• 易于对系统进行扩充和缩小• 系统中的功能构件充分隔离浏览器 / 服务器架构(调用返回风格)• B/S是C/S的扩展，瘦客户。• 应用(程序)在一定程度上具有集中特征。• 减轻安装、配置和升级等维护工作。• 层与层之间相互独立，任何一层的改变都不影响其他层原有的功能，所以可用不同厂家的产品组成性能更佳的系统。（平台透明性）MVC架构(独立构件风格)• 模型(Model)－视图(View)－控制器(Controller)• MVC是一种软件设计典范，用业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。• 视图是用户看到并与之交互的界面。• 模型表示企业数据和业务规则。• 控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何结果和做任何处理。软件架构设计• 在软件架构设计的起初，要考虑软件必须放在所处的环境。• 一旦建立了软件的环境模型，并且描述出所有的外部软件接口，那么设计师就可以通过定义和求精实现架构的构件来描述系统的结构。这个过程不停地迭代，直到获得一个完善的架构。• 通过软件架构，系统将逻辑关系密切的单元划分到一起，形成系统的逻辑划分，有利于后续独立的开发和管理。• 这个划分经常是基于类模型进行的，并可参照一些设计优化方法形成更合理的组织方式，达到模块内部的高内聚模块间的低耦合。• 软件架构对应的实现就是将软件使用所谓的“包(Package)”进行构造，每个包对应某种专属的功能，并尽可能独立。• 包中的类互相紧密配合协作完成包的功能，每个包与其他包中含有的类之间的接口应该尽可能简单，降低它们的耦合性包结构设计5. 类的分析与设计• 对未来系统的功能进行总体上的概括并使用UML的类图进行表达。• 在开始阶段粗略的对模型进行构建，后续再通过迭代逐级具体化，是一个逐步求精的设计过程。• 初始类图要覆盖所有需求的功能，并通过优化尽量保持业务结构的稳定，然后通过修订和丰富细节逐渐过渡到详细设计，并最终转化为成功的物理实现。5.1. ①基本类的确定• 设计阶段的主要任务是从需求分析阶段的规格说明出发，对系统进行模型表示并优化。• 面向对象的概要设计首先寻找系统中参与业务处理的对象和类。• 然后使用类图（Class Diagram）将系统中不同的类抽象出来描述系统的静态结构，包括类以及它们之间的关系。5.1.1. 类及其种类实体类：对应需求中的实体，通常需要永久保存，一般使用数据库表或文件来记录，既包括存储和传递数据的类，还包括操作数据的类。（名词、POJO）控制类：用于体现应用程序的执行逻辑，提供相应的业务操作，抽象控制类可以降低界面和数据库之间的耦合度。控制类有时也称为管理类。（动宾）边界类：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类以及与外部系统的数据交换类(如同步、缓存等)。类的识别• 类的寻找和细化是迭代的过程，不断补充新类及信息并逐渐扩展，最后发展为更多的类和实例变量。• 需求规格说明书是寻找业务类的直接来源。• 业务术语词汇表也是类信息的重要来源，这些与业务术语相关的类通常为实体类。2.初始类图将现在发现的所有信息融入一个类图加以表示,形成初始类图        初始类图    实体类的便携表示    可见性- : 私有,其他类对私有属性的读取只能通过类提供的方法进行+ : 公开,对所有类可见# : 受保护的,对该类的子类可见~ : 包的, 只对同一包中声明的其他类可见/ : 依赖属性, 其取值是通过其他相关变量的值计算而来  构造型&lt;&lt;entity&gt;&gt; : 实体类  &lt;&lt;boundary&gt;&gt; : 边界类   &lt;&lt;control&gt;&gt;: 控制类 3. 类的关系4.对象与类  • 系统中的每个对象在表示上具有唯一的标识ID以及通过其属性进行描述。  • 比如一个具体的项目名字为“考勤系统”，项目经理名“王楠”，项目开始日期“2010年10月20日”。这些属性称为实例变量（instance variable）或属性（attribute）。  • 同类对象的共同结构可通过类进行说明，除了类名外，所有的实例变量都可包含在类中作为类的  初始信息。因此对于“项目”类来说，它是所有具体“项目对象”的一个模板。    • 连接类与对象间的实线，表示类图中关联关系的实例化  • 对象名:类的类型  • 实例变量的初始值5.2. ②类的细化在下一轮的迭代中，将重新审视并分析需求陈述和词汇表中提到的功能与对象之间的对应关系。除了实例变量的说明，类中还包含方法，又称为操作或对象功能，它们为业务计算或对实例变量值的读写提供了服务。一个对象中所有实例变量值的组合构成了该类的状态集合。5.2.1. 管理类和控制类方法和管理类访问和修改方法，不涉及业务，在分析模型中通常不考虑，实现阶段再考虑。对象通常还提供了只需通过内部信息，如实例变量，对业务数据进行计算的方法。– 如方法computeAllocatedEffort()，计算已经对项目中的任务和子项目分配的工作量。对于同类对象的协调和管理通常使用一个管理类，主要负责对对象的创建、代理访问其它对象的信息等。管理类必须能够提供所管辖所有对象统一的处理方式。控制类控制类通常控制和协调不同对象的行为，用来封装用例的特有行为。复杂用例一般都需要一个或多个控制类。借助控制类可将边界对象与实体对象分开，让系统更能适应其边界内发生的变更。控制类还将用例所特有的行为与实体对象分开，使实体对象在用例和系统中具有更高的复用性。控制类的识别一般方法：先对所有的用例进行分析，对每个用例对应产生一个控制类，用来对该场景中需要的对象进行管理和协调。设置和细化过程中的建议控制类每次考虑一个任务，只向控制类添加与该任务相关的方法和方法需要的实例变量。类与类之间尽可能保持较少的联系，这样可以降低接口的数量。5.2.2. 设计优化5.3. ③. 补充和确认当初始版本的分析类图完整的构建出来后，需要确认是否需求中的所有信息在模型中都得到了体现而没有遗漏。可使用UML中的顺序图对需求场景中涉及到的不同对象之间的交互过程进行建模。类图在UML中是一种静态图，因为描述了系统的功能侧面，而基于类图的顺序图可以用来设计对象之间的动态交互过程，描述对象之间的过程调用顺序和关系。通过顺序图可以用来检验类图中说明的功能是否能够实现活动图中描述的功能需求。5.3.1. 顺序图对象的删除和创建结构表示场景模拟5.3.2. 通信图5.4. ④界面类设计基本要求：通过界面使得模型中含有的类的某些部分对外部可见，比如用户通过界面可进行业务内容的修改或访问，即包括人机交互界面。界面类设计通常可推迟进行，因为可以直接应用现成的类库中的模型，采用不同的类库对整体的类设计会有很大的影响。对现有的类模型补充对应的界面描述，一个直接的方法就是对于每个类补充一个对应的接口，使得它向外部提供可访问的信息。对于项目类可设置一个ProjectMask界面，对外提供项目创建和修改的操作  是一个边界类使用一个界面控制GUIControl，控制当前哪个类的界面类处于使用状态。 是一个控制类6. 代码生成• 考虑设计方案向实际运行方式的转变过程，即由概要设计产生出对应的程序代码框架的过程。• 工程化的设计方法将导致程序代码具有更好的可实现性、更好的可维护性和可修改性以及更好的可扩展性。• 先对类图到可运行程序的基本转换过程进行概要的说明，然后考虑对其优化和细化的过程。CASE工具软件开发环境软件开发的工具及其集成环境,用以支持软件开发的过程, 活动和任务, 为软件开发,维护及管理提供统一的支持, 也即计算机辅助软件工程(CASE)不同类型的项目其软件开发环境的构成使不一样的, 工具的选择也有较大的不同工具的选择会对开发过程的选择产生一定的影响, 不同的工具组合对开发过程的支持能力会有所不同. 同时涉及到工具的集成问题集成开发环境(IDE)是软件开发环境中的一种实现方式CASE环境的搭建与开发过程中的选择具有很强的依赖关系较重要的一点是要考虑开发过程中的“变更”的管理方式存在两种较为极端的情况需求分析, 概要设计和详细设计阶段只进行一次, 或者 迭代-增量式 的进行.每次修改只发生在代码, 其他文档不做更新.每个改动的意愿都要经过完整的分析, 概要设计和详细设计流程,所有必须的改动需要在所属的文档以及代码中对应修改,并保证他们的一致性两种方式的选择需要根据项目需要进行确定, 或者在两者之间折中(2)更适合项目需要长期维护, 不多扩展功能(1)更适合项目结束后不需要长期维护从类图向代码实现的转换过程中需要引入  正向 和 逆向 工程的技术方法正向工程从类图出发生成程序代码的框架, 进一步的开发可直接在代码上进行逆向工程将代码的修改方向映射回类图的设计中, 从而在设计与代码之间保证一致性一种特殊的情况是设计图纸完全由代码生成需要设计和编码工具紧密集成和配合从类图到程序代码框架的生成过程单个类的代码实现类模型的内容必须要完整, 需要包含每个实例变量,需要指定其类型每个方法中的参数和返回值, 需要指定其类型每个关联关系, 其关联关系,使用或导航方向必须说明带有下划线的方法和属性–&gt; 类变量(静态),和 类方法(静态)静态变量的使用需要仔细斟酌–&gt;破坏了面向对象的本地性(封装性)原则静态变量和静态方法通常在一般性的常规工作(记录文件的存储路径，常规的数值计算等，加密等)方法参数的输出输入类型in在方法内部是只读的, 不会被修改inout在方法的处理过程中或被访问, 修改, 方法结束后修改结果可以保持,即可以被外部接收到out只能作为方法内部计算结果–&gt;调用改方法时,out参数可以被赋予任何值(哑值), 对于方法的内部计算不起任何作用, 方法结束后该参数记录并保持计算结果实际上的补充CASE工具能够进自动进行整个代码框架的生成, 具体业务的代码一般需要人工补充业务越复杂, 代码能够自动进行的可能性就越低关联关系的实现明确了类于类之间的静态关系,关联关系最终体现为对应类中增加了实例变量变量存在的的具体形式依赖于关联的具体类型存在关联关系has :关联的名字   ▶: 关联名字的方向  (名字信息不会出现在程序代码中)加了数量关系points : 一个(集合类型)实例变量 管理这些点→ : 导航方向(能从多边形或者包含的点的信息 /  不能从点获知多边形的信息)✗:显示的表示无此导航方向 : 聚合 (另外一种关联 :部分与整体的弱包含关系–相互之间没有存在层面的依赖性) (多边形被删,点还在)组合 (特殊的关联关系, 点的存在依赖于多边形对象–多边形被删,点也被删)​    导航导航至”可选”方向导航至“唯一”方向导航至“任意”方向依赖关系描述对象间访问的瞬时性, 将某些类向其他类进行传递, 这种瞬时的关系并不在对象键保持局部变量/方法参数/对静态方法的调用可以使用&lt;&lt;include&gt;&gt;代替uses举例软件架构: MVC的实现• MVC，Model-View-Controller模式，能够很好的对设计的灵活性进行解释。• MVC的核心思想是将数据本身与其修改的方式以及数据的展现形式进行分离。• 通过MVC提供的模式，使得数据能够以各种不同的修改方式进行处理，而不影响对数据的管理和对外展现的形式。• 同时，系统中可以具有不同的数据展现方式，与其它组件是完全独立的。• 模型：业务数据实际的组织与存储。• 视图：向外界显示结果。• 控制器：改变模型中的值。7. 类的详细设计 主要活动概要设计说明书–&gt;基础• 为每个模块进行详细的算法设计。用某种图形、表格、语言等工具将每个模块处理过程的详细算法描述出来。• 为模块内的数据结构进行设计。对于需求分析、概要设计确定的概念性的数据类型进行确切的定义。• 为数据结构进行物理设计，即确定数据库的物理结构。物理结构主要指数据库的存储记录格式、存储记录安排和存储方法，这些都依赖于具体所使用的数据库系统。 其他 输入输出格式 人机交互 详细设计说明书 评审 结构化的程序如果程序的代码块仅仅通过顺序、选择和循环三种控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。目的是简化设计过程，仅使用有限的可预测的操作即可完成相应的算法流程 图形设计工具-类方法的详细设计程序流程图盒图问题分析图$(PAD)$ 表格工具-类方法的详细设计判定表/决策表构成条件列表条件组合动作列表动作入口判定树 (决策树) 语言工具-类方法的详细设计(Programming Design Language)程序设计语言容易翻译成各种编程语言不用担心语法错误, 集中精力设计接近代码实现 状态图-类的行为设计无状态对象(无记忆对象)方法的返回值对实例变量值没有任何影响有状态对象(有记忆对象)一些对象的功能需要依赖于其内部状态对象的状态以及状态变化可以借助状态图（StateDiagram）或有穷状态机（Finite State Machine）进行描述。基本结构• Entry：给出当刚进入该状态时应该进行的动作（action）。在这里可以表示一个简单的赋值操作，也可以是对一个或多个方法的调用。• Do：给出在保持该状态的过程中，对象应执行的活动。这个部分一般对那些受时间控制行为的对象比较适用，因为它们通常要求能够持续的读取信息。• Exit：这个部分描述当离开该状态时应进行的动作。             这三个部分的内容是可选的，根据需要进行取舍。状态转换• 状态通过状态转换进行过渡（Transition）。• 事件部分：转换的主要内容，状态图主要是对被动系统的行为描述，对外界的刺激事件进行相应的响应。• 条件部分：状态间的转换只有在事件被触发并且满足某个特定条件的情况下才会进行，可选。• 动作：表示当转换发生时执行的一个动作，该动作执行的时机是在转换对应的目标状态的entry事件被执行之前，即还未进入到目标状态前。状态图的扩展8. 设计优化以不变应万变尽可能提升设计方案应变能力软件模式 :  相似问题的解决方案 设计经验的总计与重用8.1. 小即是美体现设计思想的 灵活性.完整性.轻量型优化的基础8.1.1. KISS(Keep It Simple Stupid)8.1.2. YAGNI(You Ain’t Gonna Need It)8.2. 设计的味道(smell)僵化性 : 隐藏的设计关联脆弱性 : 改动-&gt;没有概念关联的地方出现问题顽固性 : 分离设计中有价值的部分并进行重用的付出和风险巨大粘滞性 : 添加新功能-&gt;拼凑代码(不愿不敢碰现有代码.不对代码重构),导致原有实际破坏退化不必要的复杂性 : 设计人员加的用不到不必要的重复性 : 导致修改无法保持一致晦涩性 : 难以阅读  丧失清晰性和表达力8.3. 设计的优化运行时的多态: 多态性在结构上形成类的继承层次重写的要求相似行为细节调整方法在相同条件下工作不应有比父类更严格的条件限制方法不能超过父类方法的状态耦合的消息链集中的设计分散交互设计: 每个类只用了解本身相关的任务—模块的组织简单化封装不能完全保证模块的独立性—需要设计中考虑被拒绝的馈赠类功能和结构的扩展继承  子类不想和父类保持一致 应该用下一种委托  新类 原类 关联关系(拥有它的一个实例变量)循环依赖8.4. 设计的基本原则隔离变化-以不变应万变对  面向对象思维  的  深化  和  具体高质量软件设计的基石8.4.1. 单一职责原则Single Responsibility Principle, SRP类功能只有一个职责:  一起”变化”的原因—两个以上变化方向,会产生过多的变化点解决方法:   拆分变化条件苛刻:  可以有多个功能:  但是如果会成为单独的变化方向—&gt; 类职责的拆分/保留功能共存(装饰模式)8.4.2. 接口隔离原则尽量接口继承 实现继承接口:   需要的操作暴露给客户–充当类的视图具体类的变化不会影响到CientCilent只需关系业务的实现, 不必关心使用对象的具体实现松耦合8.4.3. 依赖倒置原则宗旨:  依赖于抽象, 而不依赖具体扩展基础具体–&gt;扩展难度大具体类变化无常–&gt;扩展类不稳定8.4.4. 开放封闭原则The Open-Closed Principle,OCP模块  对  扩展  开放  , 对  修改  封闭给出模块  不用改写现有内部代码/逻辑基本特点模块行为可扩展源代码不允许改动OCP是相对的增加零件: 新整一个继承Part 不用改Client8.4.5. Liskov 替换原则(Liskov Substitution Principle, LSP)要求父类的地方都可以用子类无条件替换(正常工作)继承关系  与  静态属性  动态行为  相关父类型 使用前—前置条件使用后—后置条件子类型替换父类型时不能违反前后置条件—不能有更多限制8.4.6. 合成/聚合复用原则Composite/Aggregate Reuse Principle,CARP合成/聚合—-特殊关联关系委托方式实现对象间功能的重用重用委托重用–低耦合–对象间独立性继承重用–高内聚–对象间合成/聚合复用原则尽量 使用  合成/聚合 形式 的委托重用尽量  不用  继承重用例多重继承CARP8.4.6.1. 继承的使用子类–父类的特殊类型​                父类扮演的角色子类的实例永远不用转化为其他类的一个对象职责: 对父类进行扩展  重写  违反LSP可能提升8.4.7. 设计模式规则: 表示 周境(Context) 动机(System of Forces) 解决方案(Soluntion) 关系准则: 经验提取的不同层面上提供不同的层面的指导层次(处理问题的粒度) (高 $\\rightarrow$ 低)架构模式(Architectural Pattern)描述: 系统 基本 结构组织/纲要 通常提供一组事先定义好的子系统 $\\rightarrow$ 指定他们的责任 $\\rightarrow$ 给出把它们组织在一起的法则和指南 eg. N-层架构 , MVC分解: 多个设计模式的联合使用设计模式(Design Pattern)用途: 处理程序中反复出现的问题识别: 基于工程化的方法特点:对解决方案的进一步抽象抽象的设计思想的重用,代码的重用具体问题完整解决方案, 方案的一种结构实现模式(Implementation Pattern)用途: 处理具体到编程语言的问题: 类名.变量名…8.4.7.1. 抽象工厂作用: 实现耦合(客户类 创建(new) 产品类: 依赖关系)实现: 分离(产品的创建过程)8.4.7.2. 单例模式管理类和控制类作用: 方便管理和维护(相关业务类)特点: 只有单一实例 不存在副本要求构造方法私有(防止外部创建)公有方法获取实例实例变量(私有/受保护)8.4.7.3. 适配器模式作用:交互(被适配对象 和 客户类)改变类的接口 $\\rightarrow$ 接口不匹配的可以一起工作接口扩展(可 通过 装饰模式 进一步描述)工作方式委托继承8.4.7.4. 桥模式思想: 分离(抽象部分  实现部分(行为)) $\\rightarrow$ 独立地变化使用: 识别: 一个类 的 两个独立变化的维度 $\\rightarrow$ 两个独立的继承等级结构 $\\rightarrow$ 建立抽象层 和 抽象耦合抽象类: 业务方法和与之关系最密切的维度实现类: 另一个维度8.4.7.5. 装饰模式额外的责任: 加密 缓存 …(不严格按照维度变化)方式: 扩展对象的功能(对客户端透明)替代方案: (继承关系) 更灵活动态: 增加功能 撤销功能特殊形式: 将Bridge中的抽象和实现二合一有继承和组合8.4.7.6. 门面模式要求: 通信(外部 一个子系统) 通过 一个统一的 门面对象接口: 提供 一个高层次 的 $\\rightarrow$ 易于使用一个子系统 一般 一个门面类 一个实例(单例模式)–相当于适配器9. 实现技术首要任务 : 构造合适的程序架构 $\\rightarrow$ 用户需求 在未来系统中 满足/体现转换过程 : 针对算法过程的实现 / 考虑每个具体项目的约束条件相关关键技术 : 数据管理策略和方法、数据持久化、XML、领域特定语言(DSL)、模型驱动架构(MDA)、重构(Refactoring)等9.1. 非功能性需求的实现特点 : 需求涉及的范围广 类型不尽相同 $\\rightarrow$ 设计和实现 根据要求 区别对待提升性能 : 硬件 . [(考虑)算法, (监控)资源利用情况…]cache数据持久化 : 存储数据传输 : 质量(right)的需求:可测试性程序结构安全要求 : 传输安全性数据安全性操作安全性9.1.1. 分布式系统云计算分布式数据库分片投影 主服务 选择一些存在…特点: 存在多个 控制点(多个程序需同时工作) e. 操作系统中的进程复杂的问题: 进程间 信息交互的方式和规则解决方法: 与条件要求(关键区域)密切相关 e. 数据库的事务实现要求: 同构与异构对象在网络中的分布管理同步和异步调用…同步优点: 进程相互了解 各自在通信过程中所处的状态缺点: 实现相对负载的同步通信 / 执行速度变慢(相互等待)异步优点: 执行速度块(独立工作)缺点: 运行变慢/信息丢失  (缓冲区满)死锁, 竞争, 活锁活锁 : 饿死解决 : 调度问题, 公平性和合理性 做出折衷9.1.2. XMLW3M委员会定义 标准化语言描述: 模型和数据XML结构: DTD（DataTypeDefinition）和XSD（XMLSchemaDefinition）well formed: XML文档对其标准的DTD或XSD进行了说明并进行了约束，指定了该XML文档的有效性用途: 文档的存储 处理 传输处理方式: 文档对象模型(DOM)  : 复杂对象处理/随机处理文档中数据用于XML的简单API(SAX)流方式  配置文件9.1.3. 程序轮子公共的资源共享: 经常出现的问题 $\\rightarrow$ 常见解决方法 $\\rightarrow$ 提取(库函数形式)库函数: 免费或收费,都当作是对的不用测试有价值的轮子•成熟稳定，代码规范，接口友好，功能符合期望；•有相关支持的保证，如文档健全，最好要有实际用例；•社区相对活跃，用户众多，维护频繁，缺陷处理及时；•松耦合，定制容易；•价格合适，有适合的使用许可，最好是开源的。9.1.3.1. 组件特殊的对象: 对数据和方法的简单封装可以实现: 拖放式编程快速属性处理真正的面向对象设计进一步提升: 对类库思想的不是仅提供单一类的功能而是将某个子应用封装提供使用模式:设计时态运行时态9.1.3.2. Java bean组件具体的组件支持机制: Java领域特殊的类: 实现接口Serializable: 接口无任何函数一般只能由需要数据进行序列化的类使用通常这些类中的实例变量和类变量 也必须实现 Serialization接口默认的构造函数(无参)getter setterPlainOldJavaObject(POJO)9.1.3.3. 框架也是轮子快速、高效和正确的将很多 原始的工作 积累合成到一个 更大粒度 的 半成品式的系统中$\\rightarrow$真实系统: 只需进行必要的参数定制提供通用平台嵌入业务类: 接口或继承的方式 $\\rightarrow$ 定制和组件区别: 控制权在框架中要进行转移，也就是说框架中的类会去调用那些由用户补充实现的对象中的方法，而不会反过来，但这在组件中是会发生的——反射9.1.3.4. 数据的持久化方式: 物理文件方便手工编辑其他程序读取繁琐: 不同的存取方法数据库共享性: 并发使用安全性9.1.3.4.1. 文件持久化9.1.3.4.2. 数据库持久化关系型数据库: 缺点: 业务存储模型(事先设计 构建)9.1.3.5. 领域特定语言Domian Specific Language,DSL初衷:抽象指令: 为不同领域 补充 特定 的不依赖具体编程语言的 .this计算机程序设计语言: 针对某一特定领域具有受限表达性的一种 .this受限性是相对通用编程语言而言核心价值: 概念性语言(清晰准确)–表达和沟通–就系统某部分的意图(更清晰)平台无关性: DSL语言另外一个关键的作用是满足.this的要求。重新定义一个全新的语言体系是比较困难的（外部DSL），因此可以借助某种已经熟悉的语言对业务命令进行组织和定义（内部DSL）。外部DSL是一种“不同于应用系统主要使用语言”的语言内部DSL是一种通用语言的特定用法。9.1.3.6. 模型驱动架构(MDA)基本思想: 提供解决方案(正式的)–与编程语言/ 甚至框架无关使用MDA四个开发阶段CIM（ComputationIndependentModel）：聚焦于系统环境及需求，但不涉及系统内部的结构与运作细节。PIM（PlatformIndependentModel）：聚焦于系统内部细节，但不涉及实现系统的具体平台。PSM（PlatformSpecificModel）：聚焦于系统落实于特定具体平台的细节，如EJB，J2EE或.NET都是一种具体平台。Coding：最后程序员依据PSM的UML模型内容，按图施工，编写出适用于特定具体平台的代码。MDA描述的软件开发生命周期和传统生命周期没有大的不同，主要的区别在于开发过程创建的工件，包括PIM、PSM和代码。PIM是具有高抽象层次、独立任何实现技术的模型。PIM被转换为一个或多个PSM。PSM是为某种特定实现技术量身定做的模型，例如，EJBPSM是用EJB结构表达的系统模型。开发的最后一步是把每个PSM转换为代码，PSM同应用技术密切相关。MDA的变换都是由工具自动完成的，这个过程转换规则的定义也是非常重要的，即要对模型间的过渡进行形式化的描述。图中将PIM和PSM的转换描述为模型1到模型2的过渡  有模型和转换规则需要正式的语义定义，因此OMG组织出台了一系列的规范将MDA方法标准化，其中最重要的语义描述包含在规范MetaObjectFacility（MOF）中。9.1.3.7. 重构面向对象目标之一: 复杂程序的可重构性–简化程序–增加可读性详细设计文档 额外准则方法的名字要尽可能的自解释；方法最长应不超过12行，尽可能少的包含while、switch和if逻辑块。10. 交互设计可用性: 项目的成与败不具备直观的可操作性: 用户很难接受10.1. 心理学10.2. 人机工程学11. 软件测试11.1. 形式化验证基本思想(模型检测)用(状态迁移系统(S)) 表示系统行为用(模态逻辑公式(F)) 描述系统的性质转化为数学问题系统是否有所期望的性质 -&gt; .this 状态迁移系统S是否在是公式F的一个模型可判定对有穷状态系统: 可用计算机程序在有限时间内自动确定11.2. 测试技术定义运行和测定某个软件系统的过程使用人工或自动的手段目的: 1.需求2./差别检验它是否满足规定的需求预期结果与实际结果的差别并行软测和开发并行(并非开发后期的一次性活动)重视: 敏捷思想的普及测试用例(Test Case)数据集: 测试输入/执行条件/预期结果–状态体现需求: 测试某个程序路径或核实软件是否满足某个特定需求11.3. 测试分类和测试V类型类测试(单元测试)测试: 每个单一的新开发的功能模块集成测试系统测试验收测试白盒测试关注: 被测对象的内部构成细节(eg. 算法的结构/流程)采用: 多在类测试阶段灰盒测试关注: 类,包 等 程序单元之间的关系采用: 多在集成测试阶段黑盒测试关注: 系统的外部行为采用: 多在系统或验收测试阶段需要软测缺陷修正成本与曲线的类型有关 (需求阶段的成本比实现阶段高很多)缺陷越早被识别并处理成本越低ff集中管理: 所有测试用例执行的条件和预期的结果: 为每个测试具体指定11.4. 非功能测试功能性测试对软件系统的测试非功能性测试11.5. 界面测试适合使用: 等价类的方法建立对应的测试类常采用: “捕捉和回放”(Capture-and-Replay)工具11.6. 软件度量(白盒)辅助手段: 确定软件质量指标和作用:…McCabe指标:LCOM*指标节点顺序节点分支节点汇节点环形复杂度头到尾的环的数量分支节点数量+111.6.1. McCabe指标McCabe环形复杂度(McCabe值)边数-节点数+2 (入度为零和出度为零的节点不能超过一,如果他俩连接起来了就换成+1)11.6.2. LCOM*指标一个变量会在多少个方法中使用$$LCOM*=\\frac{(\\frac{1}{a}\\sum_{j=1}^{a}\\mu(A_j))-m}{1-m}$$//TODO值为零 内聚性佳 (变量被使用的多)不考虑set和get方法11.7. 覆盖指标程序覆盖是提供一组测试用例尽可能使得覆盖率指标越大越好，或者说越接近1越好。覆盖率指标有很多计算标准，其中较基础的有语句覆盖(StatementCoverage)、分支覆盖(BranchCoverage)、条件覆盖(ConditionCoverage)、多条件组合覆盖(MultipleConditionCoverage)及路径覆盖(PathCoverage)等覆盖率: 用测测试的用例的占比 –尽量的覆盖(走过)多的节点11.7.1. 语句覆盖语句覆盖表示在程序控制流图中测试经过的节点数与所有节点数的比例$$\\frac{控制流图中测试所经过的节点数}{所有节点数}$$11.7.2. 分支覆盖尽量覆盖所有边$$\\frac{控制流图中测试经过的边数}{所有的边数}$$11.7.3. 条件覆盖每个原子谓词的真假两值都要取到根据出现的bool条件进行测试用例的设计$$\\frac{取值为真的原子谓词+取值为假的原子谓词}{2*所有的原子谓词数}$$11.7.4. 多条件组合覆盖单条件和条件组合$$\\frac{取值为真的原子谓词+取值为假的原子谓词}{2*所有的原子谓词数}$$11.7.5. 路径覆盖所有可能路径的覆盖情况路径: 方法的入口到开始到出口结束独立路径: 相对与之前的有新的节点或者路径引入(每次尽量少加 -路径更多)典型方法: 基本路径测试控制流图基础上导出基本可执行的路径集合(通过分析控制结构的环形复杂度)从而设计测试用例11.7.5.1. 基本路径测试11.8. 等价类测试数值型(根据输入变量的取值范围)有效的两个无效的非数值型枚举 枚举里有的是有效其他是无效字符型长短字符集的要求字符类型基础上–边界值分析11.9. 断言(Assertation)11.10. 测试框架之Junittest drivertest casetest result12. 软件项目级管理12.1. 软件配置管理Software Configuration Management,SCM产品库管理对产品项技术(标识,组织,控制修改)贯穿整个软件声明周期12.1.1. 版本管理两方面的工作规范不同人员间的合作方式覆盖(不配别人意外覆盖)需要的版本&amp;提供基础每个人工作的对象是当前.this1 并能为后续的开发.this2回到先前工作状态的机制(累进式的开发过程)版本管理系统的核心工作项目软件/项目文档的管理版本仓库软件配置项(仓库管理的各种软件资产, 文档数据代码)12.1.2. 构建管理主要任务(构架管理系统)(描述最终软件产品的)结构和生成过程小型的开发项目调用编译器使用不同的链接器生成可执行文件并执行大型的项目重新编译和链接(被修改的部分)13. 项目计划项目成功重要因素:开发的方法技术开发环境项目管理关注: 组织和管理实际上估算项目规模、工作量、成本、进度等方面尽量估算项目的实际成本趋于准确资源统筹安排人员 时间 计算机资源项目经理-项目整体上的计划,进度控制等工作13.1. 工作分解WBS按照功能数 分解功能  主功能-子功能H图-系统功能模块划分13.2. 软件规模估算项目基于分解的方法-WBS 分解为子项目评估方式(度量单位)“类比”: 参照相似项目LOC/KLOC lines of code $S=\\frac{a+4b+c}{6}$a:悲观值b:正常值c:乐观值功能点(FPs)分析(系统化的.this): 可以进行认证的.this尽量 功能 归到5中任务类型内部逻辑文件(ILF,内部数据):在待开发系统内部处理的数据，如开发的类本身。外部结构文件（EIF，引用数据）：从开发系统的外部引入并进行处理的数据。外部输入（EI，输入）：从开发系统外部的输入，并由此对数据展开处理，如数据以某种格式约定（输入掩码）从系统外部的输入。外部输出（EO，输出）：在待开发系统中实现业务计算结果外部的输出，比如数据以某种形式的输出格式（输出掩码）或对其它系统的错误消息输出。外部查询（EQ，查询）：从外部系统发出的对数据信息的查询，对数据的查询格式、报告以及分析，不包括其它需要的附加计算。ProjectObject13.3. 开发成本估算带有权重的功能点 $\\rightleftarrows$ 工作量的评估方法经验曲线CoCoMo (Constructive Cost Model)$PM=A\\times Size^E \\times \\prod_{i=1}^{n}EM_i$Size: 不含注释的程序长度$EM_i$:公式中表示每个影响因子的变量13.4. 管理方面的成本13.5. 任务安排和工程网络图13.6. 项目组织与甘特图13.7. 项目计划跟踪13.8. 挣值分析模型BCWS(BS)（BudgetedCostofWorkScheduled）计划完成工作的预算成本:到目前为止的总预算成本ACWP (AP)(ActualCostofWorkPerformed)已完成工作的实际成本:是到目前为止所完成工作的实际成本，它说明了“到该日期为止实际花了多少钱”，可以由项目组统计。BCWP（BudgetedCostofWorkPerformed）已完成工作的顶算成本，又称挣值:是到目前为止己经完成的工作的原来预算成本，它表示了“到该日期为止完成了多少工作?”BAC(BudgetedAtCompletion):工作完成的预算成本:是项目计划中的成本估算结果，是项目完成的预计总成本进度偏差SV（ScheduleVariance）=BCWP-BCWS，若此值为零，表示按照进度进行；如果为负值，表示项目进度落后；如果为正值，表示进度超前。成本偏差CV（CostVariance）=BCWP-ACWP，若此值为零，表示按照预算成本进行;如果为负值，表示项目超出预算成本；如果为正值，表示低于预算成本。进度执行指标SPI（SchedulePerformanceIndex）=BCWP/BCWS，指项目挣值与计划值之比。当SPI&gt;1时，表示进度超前；当SPI=1时，表示实际进度与计划进度相同；当SPI&lt;1时，表示进度延误。成本执行指标CPI（CostPerformanceIndex）=BCWP/ACWP，项目挣值与实际费用之比。当CPI&gt;1时，表示低于预算，即实际费用低于预算费用；当CPI=1时，表示实际费用与预算费用吻合；当CPI&lt;1时，表示超出预算，即实际费用高于预算费用13.9. 参数取值原则计算 挣值BCWP50/50规则是当一项工作任务已经开始，但是没有完成时，我们就假定已经实现50%的价值，当这个工作任务全部完成的时候才实现全部的价值。0/100规则是当一项工作任务开始，只要没有完成时，不产生任何价值，即是0，直到完成时才实现全部的价值13.10. 项目偏差控制14. 软件过程管理和改进能力成熟度模型CMM模型 Capability Maturity ModelCMMI过程域软件过程 高质量软件 任务框架 技术 文档 管理 软件工程方法学3 组成瀑布 强迫 规范文档 质量检验 依赖文档 用户需求不软件危机 开发维护 增长需求 维护膨胀软件 开发维护特点 技术 管理 维护软工7原理现代技术 少而精 阶段生命周期 阶段评审 结果清楚审查 严格产品控制 改进软工实践软件逻辑软件配置 程序 数据 文档软件工程方法学 可维护 维护代价 方法工具过程可行性技术 经济 操作 是否值得 复查 研究 导出 解法 推荐 草拟开发计划 文档软件系统逻辑模型 数据流图 数据字典数据流图 逻辑模型 信息流 数据流(名字方向) 源终点 处理 数据存储 数据流  自顶向下 分层绘制 逐步求精 功能分解数据字典 数据流图 元素定义合集流程图 物理模型开发成本 人力消耗需求分析 理解 调查 分析软件需求 软件需求规格说明书 一致性 完整性 现实性 有效性接口需求 用户 硬件 软件 通信 逆向结构化分析方法 数据流 自顶向下 求精快速原型 快速 容易修改 演示功能可行性软件设计 总体设计 详细设计 原理模块化总体设计 系统设计 结构设计模块独立 模块化 抽象 信息隐藏 局部化概念内聚 模块 功能强度耦合 软件结构 模块 互联程度信息流 交换流 事务流事务流 数据-&gt;处理T-&gt;根据数据类型选个动作执行-&gt;数据流-&gt;事务流传统过程化详细设计 (概要设计说明书) 算法 数据结构 IO 交互 详细设计说明书 评审模块算法设计/类方法详细设计/模块处理过程/过程设计工具 图形 表格 语言PDL 作为注释 书写简单 自动处理程序实现 编码 测试单元(模块)测试 模块做为一个单元白盒 单元集成测试 子系统 检测&amp;组装-含义灰盒 类 包 程序单元 关系系统测试验收测试 实际数据黑盒 不内部结构&amp;处理过程 基本路径 条件 循环调试 发现错误后排除错误验收测试数据 正常 边界 无效可维护性 可 理解 测试 修改 移植 重用 性软件维护 改正 适应 完善 预防 性 文档决定性因素代码重构&amp;正向工程 重新 数据结构&amp;算法&amp;编码 重构不改体系结构只局部数据结构用例图活动图数据流图类图顺序图状态图工程网络图","tags":["软件工程","概述"],"categories":["软件工程","概述"]},{"title":"wsl以及vim的配置","url":"/2019/08/15/wsl以及vim配置/","content":"提示过程中如果出现了问题 第一步 切换root和非root即sudo su和exit   重试 如果不行第二步  关掉终端重新开 重试 如果不行第三步 百度,必应,google.....重试 如果不行第四步 关机重启 如果不行第五步 卸载Ubuntu  先看C:\\Users\\用户名\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\\LocalState\\rootfs这里的东西删没删掉如果删掉了就重装如果删不掉 新建txt 写进上边,后缀改成.bat  把文件夹托上去删掉 更新的部分在这里markdown 预览插件我换成了这个这个具体设置看官方文档解决访问GitHub太慢需要访问GitHub 所以要先解决这个问题https://blog.csdn.net/weixin_38437404/article/details/89489401安装Ubuntu打开适用于Linux的Windows子系统重启电脑之后Microsoft Store安装Ubuntu安装ing输入用户名 密码点Ubuntu图标–&gt;属性Ctrl shift C/V那个开  换中科大源(目前别的源后面过程有坑,别问我怎么知道)备份原来的如果没用过vim原来的都删掉复制上边的源, 然后换普通模式Esc 保存退出然后输入命令然后慢慢等安装ranger文件管理器启动ranger这里可以访问其他磁盘ranger的配置复制配置文件到主目录按 q 退出ranger进入ranger先按z再按h 查看隐藏文件这个rc.cong就是ranger的配置文件  接着按方向键→选择2, 则默认用完整版的vim打开  .tiny是简版的vim这里你可以慢慢折腾, 设置你自己的快捷键比如把 ! 改成vim新建文件可以改原来的也可以新加快捷键改完了保存退出终端关了重新打开–测试–生效Vim安装Vim插件管理器默认安装在 /.vim/bundle/vundle 目录下..vimrc 是配置文件, 为了避免配置文件过于臃肿新建一个用来管理插件的配置文件别把 . 落了在 call vundle#begin() 和 call vundle#end() 之间的就是即将要安装的插件, 上边的是我安装了的插件, 插件的功能我做了简单的注释, 具体去他们各自的GitHub上看新建配置文件别把 . 落了添加以下  前三行就是把刚刚插件的那部分加进来  后面的我都加了注释上边是对各个插件的设置, 快捷键的设置之类的, 我都加了注释, 具体看各自插件的GitHub,     README.md文件中都有具体的介绍安装插件在命令行中打开vim 使用PluginInstall命令安装插件 等+ 是装完的&gt; 正在装的完成 退出 运行有图形化界面的软件设置环境变量(配置显示设备)最后一行添加使配置生效Windows安装XmingXming下载地址安装后选这个选第一个  , displaynumber换0 (即和前面的设置对应)然后一路默认下一步装个火狐试一试火狐浏览器中文应该会乱码重启火狐MarkDown之前已经装过插件了普通模式下(按 Esc 回到普通模式)  输入前几个字母按 tab 键可以补全就可以启动火狐浏览器预览Ultisnips代码块引擎插件前面都一起装过了如果补全功能出现问题 比如按tab不能补全参考下面链接链接YouCompleteMe安装这里可能出现的错误ERROR: Python headers are missing in /usr/include/python2.7.ImportError: No module named requestsYCM和Ultisnips按键冲突解决方案（只使用TAB键，无错误）我上边给的文件已经改过了解决方法vim格式化1，gg 跳转到第一行2，shift+v 转到可视模式3，shift+g 全选4，按下 =终端美化链接其他主题参考https://blog.csdn.net/Striker_V/article/details/52592591https://www.imydl.tech/linux/431.htmlhttps://zhuanlan.zhihu.com/p/35536223https://www.jianshu.com/p/aca81f8c7f08","tags":["wsl","vim"],"categories":["wsl","vim"]}]